<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[data structure] 자료구조 정리 | slow-wave blog</title><meta name=keywords content="datastructure,자료구조,graph"><meta name=description content="0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.
Classification of Data Structure (출처)
Linear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.
Non-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/data_structure/data_structure_0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[data structure] 자료구조 정리"><meta property="og:description" content="0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.
Classification of Data Structure (출처)
Linear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.
Non-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/data_structure/data_structure_0/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-12T17:04:59+09:00"><meta property="article:modified_time" content="2022-10-12T17:04:59+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[data structure] 자료구조 정리"><meta name=twitter:description content="0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.
Classification of Data Structure (출처)
Linear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.
Non-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[data structure] 자료구조 정리","item":"http://slow-wave.github.io/post/data_structure/data_structure_0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[data structure] 자료구조 정리","name":"[data structure] 자료구조 정리","description":"0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.\nClassification of Data Structure (출처)\nLinear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.\nNon-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다.","keywords":["datastructure","자료구조","graph"],"articleBody":"0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.\nClassification of Data Structure (출처)\nLinear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.\nNon-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다. 이 구조에서는 단일 실행으로 모든 요소를 순회할 수 없습니다.\n1. stack 2. queue 3. graph graph는 Nodes/Vertices(정점)와 Edges(간선)로 구성된 비선형 데이터 구조입니다. 실생활에서는 네트워크를 나타내는데 사용됩니다.\n0) graph 관련 용어 adjacent vertex(인접 정점) : 간선에 의 해 직접 연결된 정점 degree(정점의 차수) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수 무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배 in-degree : 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름) out-degree : 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름) 방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수(내차수 + 외차수) path length(경로 길이) : 경로를 구성하는 데 사용된 간선의 수 simple path (단순 경로) : 경로 중에서 반복되는 정점이 없는 경우 cycle : 단순 경로의 시작 정점과 종료 정점이 동일한 경우 1) graph의 구성 요소 Nodes/Vertices(V)\n그래프의 기본 단위입니다. Edges(E)\nedge를 그리거나 그래프의 두 노드를 연결하는데 사용합니다. 2) graph 구현 Adjacency Matrix\nV x V 크기의 2D 배열임.\n공간을 많이 차지한다는 단점이 있음. O(V^2)\n예시 그림 code\nif __name__ == '__main__': # n is the number of vertices # m is the number of edges n, m = map(int, input().split()) adjMat = [[0 for i in range(n)]for j in range(n)] for i in range(n): u, v = map(int, input().split()) adjMat[u][v] = 1 adjMat[v][u] = 1 Adjacency List\n배열이 사용되며, 배열의 크기는 node의 수와 같음.\n예시 그림 code\nclass AdjNode: def __init__(self, data): self.vertex = data self.next = None # A class to represent a graph. A graph # is the list of the adjacency lists. # Size of the array will be the no. of the # vertices \"V\" class Graph: def __init__(self, vertices): self.V = vertices self.graph = [None] * self.V # Function to add an edge in an undirected graph def add_edge(self, src, dest): # Adding the node to the source node node = AdjNode(dest) node.next = self.graph[src] self.graph[src] = node # Adding the source node to the destination as # it is the undirected graph node = AdjNode(src) node.next = self.graph[dest] self.graph[dest] = node # Function to print the graph def print_graph(self): for i in range(self.V): print(\"Adjacency list of vertex {}\\n head\".format(i), end=\"\") temp = self.graph[i] while temp: print(\" -\u003e {}\".format(temp.vertex), end=\"\") temp = temp.next print(\" \\n\") # Driver program to the above graph class if __name__ == \"__main__\": V = 5 graph = Graph(V) graph.add_edge(0, 1) graph.add_edge(0, 4) graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(1, 4) graph.add_edge(2, 3) graph.add_edge(3, 4) graph.print_graph() # This code is contributed by Kanav Malhotra 3) graph의 종류 Null Graph : edge가 없는 경우 Trivial Graph : 1개의 vertex만 있고 edge가 없는 경우 Undirected Graph : 무방향 그래프 Directed Graph : 방향 그래프 Connected Graph : 모든 node가 연결되어 있음. Disconnected Graph : 1개의 node라도 끊어진 부분이 있음. Regular Graph : 모든 노드의 degree가 그래프의 다른 노드와 동일한 그래프 Complete Graph : 각 노드끼리 연결이 되어있는 그래프 Cycle Graph : 각 vertex의 degree가 2인 경우임. 그래프 전체가 순환됨. Cyclic Graph : 1개의 cycle이라도 존재하는 경우를 뜻함. Directed Acyclic Graph : cycle이 없는 방향 그래프 Bipartite Graph : 각 집합의 꼭짓점에 두 집합 사이의 간선이 포함되지 않도록 꼭짓점을 두 집합으로 나눌 수 있는 그래프 Weighted Graph : 가중치가 존재하는 그래프. 무방향/방향 가중치 그래프가 존재함. 방향을 가진 그래프를 network라고 함. 4) graph의 활용 컴퓨터의 제어 흐름을 나타내는데 사용 OS에서는 resource allocation graph로 사용 경로 최적화, 최단 경로를 찾는데 활용됨 P2P(Peer to Peer) application용 컴퓨터 네트워크에서 사용 DAG(Directed Acyclic Graph)는 가상화폐 기술에도 적용 5) graph의 장단점 장점 최단경로, 노드의 이웃을 쉽게 찾을 수 있음 DFS, BFS, MST와 같은 알고리즘을 구현하는데 사용 비선형 구조로 인해 복잡한 문제와 시각화를 이해하는데 도움이 됨. 단점 메모리 복잡도가 클 수 있음. 그래프의 곱셈 어려움. 참고자료 [intro]\n[geeksforgeeks] Data Structures [graph]\n[geeksforgeeks] Graph Data Structure And Algorithms [geeksforgeeks] Applications, Advantages and Disadvantages of Graph [wiki] 가중그래프 [blog] [자료구조] 그래프(Graph)란 ","wordCount":"705","inLanguage":"en","datePublished":"2022-10-12T17:04:59+09:00","dateModified":"2022-10-12T17:04:59+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/data_structure/data_structure_0/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[data structure] 자료구조 정리</h1><div class=post-meta><span title='2022-10-12 17:04:59 +0900 KST'>October 12, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;705 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/data_structure/data_structure_0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0-intro>0. Intro</a></li><li><a href=#1-stack>1. stack</a></li><li><a href=#2-queue>2. queue</a></li><li><a href=#3-graph>3. graph</a><ul><li><a href=#0-graph-관련-용어>0) graph 관련 용어</a></li><li><a href=#1-graph의-구성-요소>1) graph의 구성 요소</a></li><li><a href=#2-graph-구현>2) graph 구현</a></li><li><a href=#3-graph의-종류>3) graph의 종류</a></li><li><a href=#4-graph의-활용>4) graph의 활용</a></li><li><a href=#5-graph의-장단점>5) graph의 장단점</a></li></ul></li><li><a href=#참고자료>참고자료</a></li></ul></nav></div></details></div><div class=post-content><h2 id=0-intro>0. Intro<a hidden class=anchor aria-hidden=true href=#0-intro>#</a></h2><p>Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.</p><figure><img loading=lazy src=/images/data_structure/data_structure_1/0.png></figure><p>Classification of Data Structure (<a href=https://www.geeksforgeeks.org/data-structures/>출처</a>)</p><p>Linear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.</p><p>Non-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다. 이 구조에서는 단일 실행으로 모든 요소를 순회할 수 없습니다.</p><h2 id=1-stack>1. stack<a hidden class=anchor aria-hidden=true href=#1-stack>#</a></h2><h2 id=2-queue>2. queue<a hidden class=anchor aria-hidden=true href=#2-queue>#</a></h2><h2 id=3-graph>3. graph<a hidden class=anchor aria-hidden=true href=#3-graph>#</a></h2><p>graph는 Nodes/Vertices(정점)와 Edges(간선)로 구성된 비선형 데이터 구조입니다. 실생활에서는 네트워크를 나타내는데 사용됩니다.</p><h3 id=0-graph-관련-용어>0) graph 관련 용어<a hidden class=anchor aria-hidden=true href=#0-graph-관련-용어>#</a></h3><ul><li>adjacent vertex(인접 정점) : 간선에 의 해 직접 연결된 정점</li><li>degree(정점의 차수) : 무방향 그래프에서 하나의 정점에 인접한 정점의 수
무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배</li><li>in-degree : 방향 그래프에서 외부에서 오는 간선의 수 (내차수 라고도 부름)</li><li>out-degree : 방향 그래픙에서 외부로 향하는 간선의 수 (외차수 라고도 부름)
방향 그래프에 있는 정점의 진입 차수 또는 진출 차수의 합 = 방향 그래프의 간선의 수(내차수 + 외차수)</li><li>path length(경로 길이) : 경로를 구성하는 데 사용된 간선의 수</li><li>simple path (단순 경로) : 경로 중에서 반복되는 정점이 없는 경우</li><li>cycle : 단순 경로의 시작 정점과 종료 정점이 동일한 경우</li></ul><h3 id=1-graph의-구성-요소>1) graph의 구성 요소<a hidden class=anchor aria-hidden=true href=#1-graph의-구성-요소>#</a></h3><ul><li><p>Nodes/Vertices(V)</p><ul><li>그래프의 기본 단위입니다.</li></ul></li><li><p>Edges(E)</p><ul><li>edge를 그리거나 그래프의 두 노드를 연결하는데 사용합니다.</li></ul></li></ul><h3 id=2-graph-구현>2) graph 구현<a hidden class=anchor aria-hidden=true href=#2-graph-구현>#</a></h3><ul><li><p>Adjacency Matrix</p><ul><li><p>V x V 크기의 2D 배열임.</p></li><li><p>공간을 많이 차지한다는 단점이 있음. O(V^2)</p></li><li><p>예시 그림<figure><img loading=lazy src=/images/data_structure/data_structure_1/8.png></figure></p></li><li><p>code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>#  n is the number of vertices</span>
</span></span><span class=line><span class=cl>    <span class=c1>#  m is the number of edges</span>
</span></span><span class=line><span class=cl>    <span class=n>n</span><span class=p>,</span> <span class=n>m</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>adjMat</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span><span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>u</span><span class=p>,</span> <span class=n>v</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>adjMat</span><span class=p>[</span><span class=n>u</span><span class=p>][</span><span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=n>adjMat</span><span class=p>[</span><span class=n>v</span><span class=p>][</span><span class=n>u</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span></code></pre></div></li></ul></li><li><p>Adjacency List</p><ul><li><p>배열이 사용되며, 배열의 크기는 node의 수와 같음.</p></li><li><p>예시 그림<figure><img loading=lazy src=/images/data_structure/data_structure_1/9.png></figure></p></li><li><p>code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>AdjNode</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>data</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>vertex</span> <span class=o>=</span> <span class=n>data</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># A class to represent a graph. A graph</span>
</span></span><span class=line><span class=cl><span class=c1># is the list of the adjacency lists.</span>
</span></span><span class=line><span class=cl><span class=c1># Size of the array will be the no. of the</span>
</span></span><span class=line><span class=cl><span class=c1># vertices &#34;V&#34;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>vertices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>V</span> <span class=o>=</span> <span class=n>vertices</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>graph</span> <span class=o>=</span> <span class=p>[</span><span class=kc>None</span><span class=p>]</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>V</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Function to add an edge in an undirected graph</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_edge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>dest</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Adding the node to the source node</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>AdjNode</span><span class=p>(</span><span class=n>dest</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>src</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>src</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Adding the source node to the destination as</span>
</span></span><span class=line><span class=cl>        <span class=c1># it is the undirected graph</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span> <span class=o>=</span> <span class=n>AdjNode</span><span class=p>(</span><span class=n>src</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>dest</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>dest</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Function to print the graph</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>print_graph</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>V</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Adjacency list of vertex </span><span class=si>{}</span><span class=se>\n</span><span class=s2> head&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>i</span><span class=p>),</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>graph</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>temp</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=s2>&#34; -&gt; </span><span class=si>{}</span><span class=s2>&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>temp</span><span class=o>.</span><span class=n>vertex</span><span class=p>),</span> <span class=n>end</span><span class=o>=</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>temp</span> <span class=o>=</span> <span class=n>temp</span><span class=o>.</span><span class=n>next</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34; </span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Driver program to the above graph class</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>V</span> <span class=o>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=n>Graph</span><span class=p>(</span><span class=n>V</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>add_edge</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>graph</span><span class=o>.</span><span class=n>print_graph</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># This code is contributed by Kanav Malhotra</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=3-graph의-종류>3) graph의 종류<a hidden class=anchor aria-hidden=true href=#3-graph의-종류>#</a></h3><figure><img loading=lazy src=/images/data_structure/data_structure_1/1.png></figure><ul><li>Null Graph : edge가 없는 경우</li><li>Trivial Graph : 1개의 vertex만 있고 edge가 없는 경우</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/2.png></figure><ul><li>Undirected Graph : 무방향 그래프</li><li>Directed Graph : 방향 그래프</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/3.png></figure><ul><li>Connected Graph : 모든 node가 연결되어 있음.</li><li>Disconnected Graph : 1개의 node라도 끊어진 부분이 있음.</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/4.png></figure><ul><li>Regular Graph : 모든 노드의 degree가 그래프의 다른 노드와 동일한 그래프</li><li>Complete Graph : 각 노드끼리 연결이 되어있는 그래프</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/5.png></figure><ul><li>Cycle Graph : 각 vertex의 degree가 2인 경우임. 그래프 전체가 순환됨.</li><li>Cyclic Graph : 1개의 cycle이라도 존재하는 경우를 뜻함.</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/6.png></figure><ul><li>Directed Acyclic Graph : cycle이 없는 방향 그래프</li><li>Bipartite Graph : 각 집합의 꼭짓점에 두 집합 사이의 간선이 포함되지 않도록 꼭짓점을 두 집합으로 나눌 수 있는 그래프</li></ul><figure><img loading=lazy src=/images/data_structure/data_structure_1/7.png></figure><ul><li>Weighted Graph : 가중치가 존재하는 그래프. 무방향/방향 가중치 그래프가 존재함.<ul><li>방향을 가진 그래프를 network라고 함.</li></ul></li></ul><h3 id=4-graph의-활용>4) graph의 활용<a hidden class=anchor aria-hidden=true href=#4-graph의-활용>#</a></h3><ul><li>컴퓨터의 제어 흐름을 나타내는데 사용</li><li>OS에서는 resource allocation graph로 사용</li><li>경로 최적화, 최단 경로를 찾는데 활용됨</li><li>P2P(Peer to Peer) application용 컴퓨터 네트워크에서 사용</li><li>DAG(Directed Acyclic Graph)는 가상화폐 기술에도 적용</li></ul><h3 id=5-graph의-장단점>5) graph의 장단점<a hidden class=anchor aria-hidden=true href=#5-graph의-장단점>#</a></h3><ul><li>장점<ul><li>최단경로, 노드의 이웃을 쉽게 찾을 수 있음</li><li>DFS, BFS, MST와 같은 알고리즘을 구현하는데 사용</li><li>비선형 구조로 인해 복잡한 문제와 시각화를 이해하는데 도움이 됨.</li></ul></li><li>단점<ul><li>메모리 복잡도가 클 수 있음.</li><li>그래프의 곱셈 어려움.</li></ul></li></ul><h2 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h2><p>[intro]</p><ul><li><a href=https://www.geeksforgeeks.org/data-structures/>[geeksforgeeks] <strong>Data Structures</strong></a></li></ul><p>[graph]</p><ul><li><a href=https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/>[geeksforgeeks] <strong>Graph Data Structure And Algorithms</strong></a></li><li><a href=https://www.geeksforgeeks.org/applications-advantages-and-disadvantages-of-graph/>[geeksforgeeks] Applications, Advantages and Disadvantages of Graph</a></li><li><a href=https://ko.wikipedia.org/wiki/%EA%B0%80%EC%A4%91_%EA%B7%B8%EB%9E%98%ED%94%84>[wiki] 가중그래프</a></li><li><a href=https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html>[blog] [자료구조] 그래프(Graph)란</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/datastructure/>datastructure</a></li><li><a href=http://slow-wave.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/>자료구조</a></li><li><a href=http://slow-wave.github.io/tags/graph/>graph</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/algorithm/algo_mst_1/><span class=title>« Prev</span><br><span>[algorithm] MST(Minimum Spanning Tree)</span></a>
<a class=next href=http://slow-wave.github.io/post/deeplearning/deeplearning_1/><span class=title>Next »</span><br><span>[deeplearing] CNN</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>