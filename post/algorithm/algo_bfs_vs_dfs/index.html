<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[algorithm] DFS vs. BFS | slow-wave blog</title><meta name=keywords content="BFS,DFS"><meta name=description content="Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.
DFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.
inorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[algorithm] DFS vs. BFS"><meta property="og:description" content="Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.
DFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.
inorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-08-10T21:50:38+09:00"><meta property="article:modified_time" content="2022-08-10T21:50:38+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[algorithm] DFS vs. BFS"><meta name=twitter:description content="Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.
DFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.
inorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[algorithm] DFS vs. BFS","item":"http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[algorithm] DFS vs. BFS","name":"[algorithm] DFS vs. BFS","description":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.","keywords":["BFS","DFS"],"articleBody":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다. recursion 이용한 순회 방법 (DFS의 경우 재귀 호출을 이용하면 코드가 간결해진다.) 노드에 방문하면 데이터를 출력하고 자식들을 순서대로 재귀호출한다. 자식들이 호출받으면 자기를 출력하고 자식들을 호출 만약 재귀호출을 다녀와서 출력하면 자식들이 먼저 출력하니깐 거꾸로 올라가게됨. 자식이 1개 이상인 경우 stack은 쌓고 나서 호출 → 자식 중에서 나중에 들어간 node가 먼저 출력된다. 재귀 호출은 정방향으로 출력하기 때문에 다르다. 연결 관계를 입력할 때 어떤 노드와의 입력관계를 먼저 입력했느냐로 결정된다. (예시 - L 먼저 입력 됐다고 가정) 활용 모든 노드를 방문 할 때, 완전 탐색을 할 때 사용한다. 시간 복잡도 BFS(Breadth-First-Search) 정의 Root node 혹은 다른 임의의 node에서 시작해서 인접한 node를 먼저 탐색하는 방법이다.\n구현 방법 queue를 이용해서 구현한다.\n처음에는 queue에 node가 없으니깐 시작할 node를 넣는다. queue에서 node를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. 활용 최단 경로를 찾을 때 사용한다. (가중치가 0,1인 경우에만 활용할 수 있다.)\n","wordCount":"216","inLanguage":"en","datePublished":"2022-08-10T21:50:38+09:00","dateModified":"2022-08-10T21:50:38+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[algorithm] DFS vs. BFS</h1><div class=post-meta><span title='2022-08-10 21:50:38 +0900 KST'>August 10, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;216 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/algorithm/algo_bfs_vs_dfs.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#dfsdepth-first-search>DFS(Depth-First-Search)</a><ul><li><a href=#정의>정의</a></li><li><a href=#구현-방법>구현 방법</a></li><li><a href=#활용>활용</a></li><li><a href=#시간-복잡도>시간 복잡도</a></li></ul></li><li><a href=#bfsbreadth-first-search>BFS(Breadth-First-Search)</a><ul><li><a href=#정의-1>정의</a></li></ul></li><li><a href=#구현-방법-1>구현 방법</a><ul><li><a href=#활용-1>활용</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=graph-search>Graph Search<a hidden class=anchor aria-hidden=true href=#graph-search>#</a></h1><p>graph search 방법에는 DFS, BFS 2가지 종류가 있다.</p><h2 id=dfsdepth-first-search>DFS(Depth-First-Search)<a hidden class=anchor aria-hidden=true href=#dfsdepth-first-search>#</a></h2><h3 id=정의>정의<a hidden class=anchor aria-hidden=true href=#정의>#</a></h3><p>root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.</p><p>binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.</p><ul><li>inorder</li><li>preorder</li><li>postorder</li></ul><h3 id=구현-방법>구현 방법<a hidden class=anchor aria-hidden=true href=#구현-방법>#</a></h3><ol><li>stack을 이용해서 구현</li></ol><ul><li>처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다.</li><li>stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다.</li><li>child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.</li></ul><ol start=2><li>recursion 이용한 순회 방법 (DFS의 경우 재귀 호출을 이용하면 코드가 간결해진다.)</li></ol><ul><li>노드에 방문하면 데이터를 출력하고 자식들을 순서대로 재귀호출한다.</li><li>자식들이 호출받으면 자기를 출력하고 자식들을 호출<ul><li>만약 재귀호출을 다녀와서 출력하면 자식들이 먼저 출력하니깐 거꾸로 올라가게됨.</li></ul></li><li>자식이 1개 이상인 경우<ul><li>stack은 쌓고 나서 호출 → 자식 중에서 나중에 들어간 node가 먼저 출력된다.</li><li>재귀 호출은 정방향으로 출력하기 때문에 다르다.<ul><li>연결 관계를 입력할 때 어떤 노드와의 입력관계를 먼저 입력했느냐로 결정된다. (예시 - L 먼저 입력 됐다고 가정)</li></ul></li></ul></li></ul><h3 id=활용>활용<a hidden class=anchor aria-hidden=true href=#활용>#</a></h3><ul><li>모든 노드를 방문 할 때, 완전 탐색을 할 때 사용한다.</li></ul><h3 id=시간-복잡도>시간 복잡도<a hidden class=anchor aria-hidden=true href=#시간-복잡도>#</a></h3><h2 id=bfsbreadth-first-search>BFS(Breadth-First-Search)<a hidden class=anchor aria-hidden=true href=#bfsbreadth-first-search>#</a></h2><h3 id=정의-1>정의<a hidden class=anchor aria-hidden=true href=#정의-1>#</a></h3><p>Root node 혹은 다른 임의의 node에서 시작해서 인접한 node를 먼저 탐색하는 방법이다.</p><h2 id=구현-방법-1>구현 방법<a hidden class=anchor aria-hidden=true href=#구현-방법-1>#</a></h2><p>queue를 이용해서 구현한다.</p><ul><li>처음에는 queue에 node가 없으니깐 시작할 node를 넣는다.</li><li>queue에서 node를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다.</li></ul><h3 id=활용-1>활용<a hidden class=anchor aria-hidden=true href=#활용-1>#</a></h3><ul><li>최단 경로를 찾을 때 사용한다.</li></ul><p>(가중치가 0,1인 경우에만 활용할 수 있다.)</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/bfs/>BFS</a></li><li><a href=http://slow-wave.github.io/tags/dfs/>DFS</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_0/><span class=title>« Prev</span><br><span>[백준] DFS/BFS 1- 1260번 DFS와 BFS</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>