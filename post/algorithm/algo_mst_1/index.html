<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[algorithm] MST(Minimum Spanning Tree) | slow-wave blog</title><meta name=keywords content="MST,prim,Kruskal"><meta name=description content="0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.
n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.
1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/algorithm/algo_mst_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[algorithm] MST(Minimum Spanning Tree)"><meta property="og:description" content="0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.
n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.
1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/algorithm/algo_mst_1/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-13T17:08:34+09:00"><meta property="article:modified_time" content="2022-10-13T17:08:34+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[algorithm] MST(Minimum Spanning Tree)"><meta name=twitter:description content="0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.
n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.
1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[algorithm] MST(Minimum Spanning Tree)","item":"http://slow-wave.github.io/post/algorithm/algo_mst_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[algorithm] MST(Minimum Spanning Tree)","name":"[algorithm] MST(Minimum Spanning Tree)","description":"0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.\nn개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.\n1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다.","keywords":["MST","prim","Kruskal"],"articleBody":"0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.\nn개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.\n1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다.\n최소 비용의 간선으로 구성 사이클을 포함하지 않음 MST를 구하는 방법들은 greedy algorithm으로 구현이 되어 있습니다. 대표적인 것에는 Kruskal Algorithm과 Prim Algorithm이 있습니다.\n2-1. Kruskal MST Algorithm 0) 정의 Kruskal은 간선 선택을 기반으로 하는 알고리즘입니다. 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법입니다.\n1) 과정 [1] 그래프의 간선들을 가중치의 오름차순으로 정렬한다.\n[2] 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.\n[3] 해당 간선을 현재의 MST의 집합에 추가한다.\n그림 설명 2) code #kruskal algorithm parent = dict() # 각 정점의 root node(부모)를 표현한 배열 rank = dict() #node 초기화 def make_set(node): parent[node] = node rank[node] = 0 #해당 node의 최상위 정점을 찾는다 (가장 낮은 가중치 선택) def find(node): if parent[node] != node: parent[node] = find(parent[node]) return parent[node] #두 정점을 연결한다 def union(node1, node2): root1 = find(node1) root2 = find(node2) if root1 != root2: if rank[root1] \u003e rank[root2]: parent[root2] = root1 else: parent[root1] = root2 if rank[root1] == rank[root2]: rank[root2] += 1 def kruskal(graph): minimum_spanning_tree = [] #초기화 for node in graph['nodes']: make_set(node) #1) 간선 weight 기반 sorting edges = graph['edges'] edges.sort() #오름차순 정렬 #2) 간선 연결 (사이클 없게) for edge in edges: weight, node1, node2 = edge #만약 사이클이 발생하지 않는다면 (node1과 node2의 최상위 정점이 같지 않다면) if find(node1) != find(node2): #루트노드가 다르므로 union union(node1, node2) #3) 간선 추가 minimum_spanning_tree.append(edge) return minimum_spanning_tree def solution(): graph = {'nodes': [1, 2, 3, 4], 'edges': [(1,1,2),(1,1,3),(1,2,3),(1,3,4),(3,2,4)]} #(weight,node1,node2) return kruskal(graph) solution() # 결과 : [(1, 1, 2), (1, 1, 3), (1, 3, 4)] # 가중치의 합 : 3 2-2. Prim MST Algorithm 0) 정의 Prim은 정점 선택을 기반으로 하는 알고리즘입니다. 이전 단계에서 만들어진 신장 트리를 확장하는 방법입니다.\n1) 과정 [1] 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.\n[2] 앞 단계에서 만들어진 MST집합에 인접한 정점들 중에서 최소 간선으로(가장 낮은 가중치로) 연결된 정점을 선택하여 트리를 확장한다.\n[3] (n-1)개의 간선을 가질 때까지 반복한다.\n2) code edge 탐색을 위해 min heap 을 이용한 priority queue를 사용합니다. priority queue는 우선 순위가 가장 높은 자료를 가장 먼저 꺼낼 수 있는 자료 구조입니다. python에서는 이를 구현한 heapq 라이브러리가 있습니다. #prim algorithm from collections import defaultdict from heapq import * def prim(first_node, graph): minimum_spanning_tree = [] adjacent_edges = defaultdict(list) for weight, node1, node2 in graph: adjacent_edges[node1].append((weight, node1, node2)) adjacent_edges[node2].append((weight, node2, node1)) connected = set(first_node) candidated_edge = adjacent_edges[first_node] heapify(candidated_edge) while candidated_edge: weight, node1, node2 = heappop(candidated_edge) if node2 not in connected: connected.add(node2) minimum_spanning_tree.append((weight, node1, node2)) for edge in adjacent_edges[node2]: if edge[2] not in connected: heappush(candidated_edge, edge) return minimum_spanning_tree def solution(): graph = [(1,'1','2'),(1,'1','3'),(1,'2','3'),(1,'3','4'),(3,'2','4')] return prim('1',graph) solution() #결과 : [(1, '1', '2'), (1, '1', '3'), (1, '3', '4')] 참고 자료 [blog] **[알고리즘] 최소 신장 트리(MST, Minimum Spanning Tree)란** [blog] 6-5. 신장 트리와 최소 비용 신장 트리 ","wordCount":"518","inLanguage":"en","datePublished":"2022-10-13T17:08:34+09:00","dateModified":"2022-10-13T17:08:34+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/algorithm/algo_mst_1/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[algorithm] MST(Minimum Spanning Tree)</h1><div class=post-meta><span title='2022-10-13 17:08:34 +0900 KST'>October 13, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;518 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/algorithm/algo_MST_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0-spanning-tree>0. Spanning Tree</a></li><li><a href=#1-minimum-spanning-tree-mst>1. Minimum Spanning Tree (MST)</a></li><li><a href=#2-1-kruskal-mst-algorithm>2-1. Kruskal MST Algorithm</a><ul><li><a href=#0-정의>0) 정의</a></li><li><a href=#1-과정>1) 과정</a></li><li><a href=#2-code>2) code</a></li></ul></li><li><a href=#2-2-prim-mst-algorithm>2-2. Prim MST Algorithm</a><ul><li><a href=#0-정의-1>0) 정의</a></li><li><a href=#1-과정-1>1) 과정</a></li><li><a href=#2-code-1>2) code</a></li></ul></li><li><a href=#참고-자료>참고 자료</a></li></ul></nav></div></details></div><div class=post-content><h2 id=0-spanning-tree>0. Spanning Tree<a hidden class=anchor aria-hidden=true href=#0-spanning-tree>#</a></h2><figure><img loading=lazy src=/images/algorithm/MST_1/0.png></figure><p>Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.</p><p>n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.</p><h2 id=1-minimum-spanning-tree-mst>1. Minimum Spanning Tree (MST)<a hidden class=anchor aria-hidden=true href=#1-minimum-spanning-tree-mst>#</a></h2><p>MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다.</p><ul><li>최소 비용의 간선으로 구성</li><li>사이클을 포함하지 않음</li></ul><p>MST를 구하는 방법들은 greedy algorithm으로 구현이 되어 있습니다. 대표적인 것에는 Kruskal Algorithm과 Prim Algorithm이 있습니다.</p><h2 id=2-1-kruskal-mst-algorithm>2-1. Kruskal MST Algorithm<a hidden class=anchor aria-hidden=true href=#2-1-kruskal-mst-algorithm>#</a></h2><h3 id=0-정의>0) 정의<a hidden class=anchor aria-hidden=true href=#0-정의>#</a></h3><p>Kruskal은 <strong>간선 선택</strong>을 기반으로 하는 알고리즘입니다. 이전 단계에서 만들어진 신장 트리와는 상관없이 무조건 최소 간선만을 선택하는 방법입니다.</p><h3 id=1-과정>1) 과정<a hidden class=anchor aria-hidden=true href=#1-과정>#</a></h3><p>[1] 그래프의 간선들을 가중치의 오름차순으로 정렬한다.</p><p>[2] 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.</p><p>[3] 해당 간선을 현재의 MST의 집합에 추가한다.</p><ul><li>그림 설명</li></ul><figure><img loading=lazy src=/images/algorithm/algo_MST_1/1.png></figure><h3 id=2-code>2) code<a hidden class=anchor aria-hidden=true href=#2-code>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#kruskal algorithm</span>
</span></span><span class=line><span class=cl><span class=n>parent</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span> <span class=c1># 각 정점의 root node(부모)를 표현한 배열</span>
</span></span><span class=line><span class=cl><span class=n>rank</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#node 초기화</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>make_set</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>parent</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>node</span>
</span></span><span class=line><span class=cl>    <span class=n>rank</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#해당 node의 최상위 정점을 찾는다 (가장 낮은 가중치 선택)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>parent</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>!=</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>parent</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>parent</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>parent</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#두 정점을 연결한다</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=n>node1</span><span class=p>,</span> <span class=n>node2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>root1</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>node1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>root2</span> <span class=o>=</span> <span class=n>find</span><span class=p>(</span><span class=n>node2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>root1</span> <span class=o>!=</span> <span class=n>root2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>rank</span><span class=p>[</span><span class=n>root1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>rank</span><span class=p>[</span><span class=n>root2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=p>[</span><span class=n>root2</span><span class=p>]</span> <span class=o>=</span> <span class=n>root1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>parent</span><span class=p>[</span><span class=n>root1</span><span class=p>]</span> <span class=o>=</span> <span class=n>root2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>rank</span><span class=p>[</span><span class=n>root1</span><span class=p>]</span> <span class=o>==</span> <span class=n>rank</span><span class=p>[</span><span class=n>root2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>rank</span><span class=p>[</span><span class=n>root2</span><span class=p>]</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>kruskal</span><span class=p>(</span><span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>minimum_spanning_tree</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#초기화</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>[</span><span class=s1>&#39;nodes&#39;</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=n>make_set</span><span class=p>(</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#1) 간선 weight 기반 sorting</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span> <span class=o>=</span> <span class=n>graph</span><span class=p>[</span><span class=s1>&#39;edges&#39;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>edges</span><span class=o>.</span><span class=n>sort</span><span class=p>()</span> <span class=c1>#오름차순 정렬</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>#2) 간선 연결 (사이클 없게)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>edges</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span><span class=p>,</span> <span class=n>node1</span><span class=p>,</span> <span class=n>node2</span> <span class=o>=</span> <span class=n>edge</span>
</span></span><span class=line><span class=cl>        <span class=c1>#만약 사이클이 발생하지 않는다면 (node1과 node2의 최상위 정점이 같지 않다면)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>find</span><span class=p>(</span><span class=n>node1</span><span class=p>)</span> <span class=o>!=</span> <span class=n>find</span><span class=p>(</span><span class=n>node2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1>#루트노드가 다르므로 union</span>
</span></span><span class=line><span class=cl>            <span class=n>union</span><span class=p>(</span><span class=n>node1</span><span class=p>,</span> <span class=n>node2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>#3) 간선 추가</span>
</span></span><span class=line><span class=cl>            <span class=n>minimum_spanning_tree</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>minimum_spanning_tree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solution</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;nodes&#39;</span><span class=p>:</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>],</span>
</span></span><span class=line><span class=cl>             <span class=s1>&#39;edges&#39;</span><span class=p>:</span> <span class=p>[(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>),(</span><span class=mi>3</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>4</span><span class=p>)]}</span> <span class=c1>#(weight,node1,node2)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>kruskal</span><span class=p>(</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>solution</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># 결과 : [(1, 1, 2), (1, 1, 3), (1, 3, 4)]</span>
</span></span><span class=line><span class=cl><span class=c1># 가중치의 합 : 3</span>
</span></span></code></pre></div><h2 id=2-2-prim-mst-algorithm>2-2. Prim MST Algorithm<a hidden class=anchor aria-hidden=true href=#2-2-prim-mst-algorithm>#</a></h2><h3 id=0-정의-1>0) 정의<a hidden class=anchor aria-hidden=true href=#0-정의-1>#</a></h3><p>Prim은 <strong>정점 선택</strong>을 기반으로 하는 알고리즘입니다. 이전 단계에서 만들어진 신장 트리를 확장하는 방법입니다.</p><h3 id=1-과정-1>1) 과정<a hidden class=anchor aria-hidden=true href=#1-과정-1>#</a></h3><p>[1] 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.</p><p>[2] 앞 단계에서 만들어진 MST집합에 인접한 정점들 중에서 최소 간선으로(가장 낮은 가중치로) 연결된 정점을 선택하여 트리를 확장한다.</p><p>[3] (n-1)개의 간선을 가질 때까지 반복한다.</p><h3 id=2-code-1>2) code<a hidden class=anchor aria-hidden=true href=#2-code-1>#</a></h3><ul><li>edge 탐색을 위해 min heap 을 이용한 priority queue를 사용합니다. priority queue는 우선 순위가 가장 높은 자료를 가장 먼저 꺼낼 수 있는 자료 구조입니다. python에서는 이를 구현한 heapq 라이브러리가 있습니다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#prim algorithm</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>heapq</span> <span class=kn>import</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>prim</span><span class=p>(</span><span class=n>first_node</span><span class=p>,</span> <span class=n>graph</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>minimum_spanning_tree</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>adjacent_edges</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>weight</span><span class=p>,</span> <span class=n>node1</span><span class=p>,</span> <span class=n>node2</span> <span class=ow>in</span> <span class=n>graph</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacent_edges</span><span class=p>[</span><span class=n>node1</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>node1</span><span class=p>,</span> <span class=n>node2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>adjacent_edges</span><span class=p>[</span><span class=n>node2</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>node2</span><span class=p>,</span> <span class=n>node1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>connected</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>first_node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>candidated_edge</span> <span class=o>=</span> <span class=n>adjacent_edges</span><span class=p>[</span><span class=n>first_node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>heapify</span><span class=p>(</span><span class=n>candidated_edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=n>candidated_edge</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>weight</span><span class=p>,</span> <span class=n>node1</span><span class=p>,</span> <span class=n>node2</span> <span class=o>=</span> <span class=n>heappop</span><span class=p>(</span><span class=n>candidated_edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node2</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>connected</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>connected</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>node2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>minimum_spanning_tree</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>weight</span><span class=p>,</span> <span class=n>node1</span><span class=p>,</span> <span class=n>node2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>edge</span> <span class=ow>in</span> <span class=n>adjacent_edges</span><span class=p>[</span><span class=n>node2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>edge</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>connected</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>heappush</span><span class=p>(</span><span class=n>candidated_edge</span><span class=p>,</span> <span class=n>edge</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>minimum_spanning_tree</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>solution</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>graph</span> <span class=o>=</span> <span class=p>[(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;1&#39;</span><span class=p>,</span><span class=s1>&#39;2&#39;</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;1&#39;</span><span class=p>,</span><span class=s1>&#39;3&#39;</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;2&#39;</span><span class=p>,</span><span class=s1>&#39;3&#39;</span><span class=p>),(</span><span class=mi>1</span><span class=p>,</span><span class=s1>&#39;3&#39;</span><span class=p>,</span><span class=s1>&#39;4&#39;</span><span class=p>),(</span><span class=mi>3</span><span class=p>,</span><span class=s1>&#39;2&#39;</span><span class=p>,</span><span class=s1>&#39;4&#39;</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>prim</span><span class=p>(</span><span class=s1>&#39;1&#39;</span><span class=p>,</span><span class=n>graph</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>solution</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>#결과 : [(1, &#39;1&#39;, &#39;2&#39;), (1, &#39;1&#39;, &#39;3&#39;), (1, &#39;3&#39;, &#39;4&#39;)]</span>
</span></span></code></pre></div><hr><h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><ul><li><a href=https://gmlwjd9405.github.io/2018/08/28/algorithm-mst.html>[blog] **[알고리즘] 최소 신장 트리(MST, Minimum Spanning Tree)란**</a></li><li><a href=https://kingpodo.tistory.com/49>[blog] <strong>6-5. 신장 트리와 최소 비용 신장 트리</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/mst/>MST</a></li><li><a href=http://slow-wave.github.io/tags/prim/>prim</a></li><li><a href=http://slow-wave.github.io/tags/kruskal/>Kruskal</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/><span class=title>« Prev</span><br><span>[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작</span></a>
<a class=next href=http://slow-wave.github.io/post/data_structure/ds_intro/><span class=title>Next »</span><br><span>[data structure] 자료구조 정리</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>