<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[토비의 스프링 3.1] 6장 정리 | slow-wave blog</title><meta name=keywords content="Spring,Backend,Java"><meta name=description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/spring/spring_toby_7/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[토비의 스프링 3.1] 6장 정리"><meta property="og:description" content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/spring/spring_toby_7/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-05T04:56:34+09:00"><meta property="article:modified_time" content="2023-02-05T04:56:34+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[토비의 스프링 3.1] 6장 정리"><meta name=twitter:description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[토비의 스프링 3.1] 6장 정리","item":"http://slow-wave.github.io/post/spring/spring_toby_7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[토비의 스프링 3.1] 6장 정리","name":"[토비의 스프링 3.1] 6장 정리","description":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs.","keywords":["Spring","Backend","Java"],"articleBody":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs. 통합 테스트 항상 단위테스트를 먼저 고려함. 외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임. 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임. 목 프레임워크 단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.) Mockito 프레임워크 목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임. mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드 Mockito 사용 단계 @Test public void mockUpgradeLevels() throws Exception { UserServiceImpl userServiceImpl = new UserServiceImpl(); //1) 인터페이스를 이용해 목 오브젝트 생성 UserDao mockUserDao = mock(UserDao.class); //2) 목 오브젝트가 리턴할 값이 있으면 지정 //mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴 when(mockUserDao.getAll()).thenReturn(this.users); //3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함. userServiceImpl.setUserDao(mockUserDao); ... //4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다. //update() 메소드가 두 번 호출됐는지 확인 verify(mockUserDao, times(2)).update(any(User.class)); ... } 다이내믹 프록시와 팩토리 빈 프록시 - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것 프록시의 특징은 타깃과 같은 인터페이스 구현 \u0026 프록시가 타깃을 제어할 수 있는 위치에 있음 사용목적에 따른 구분 클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴 타깃에 부가적인 기능 부여 → 데코레이터 패턴 타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트 데코레이터 패턴 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임. 다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음. 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음. 프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦. 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임. 프록시 패턴 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌. 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함. 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함. 구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음. 다이내믹 프록시 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임. 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있음. java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음. 프록시의 기능 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임 지정된 요청에 대해서는 부가기능 수행 프록시 만들기가 번거로운 이유 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움. → JDK의 다이내믹 프록시로 해결 부가기능 코드가 중복될 가능성이 있음. 리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임. java.lang.reflect.Method 인터페이스 메소드에 대한 자세한 정보를 담고 있음. 특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌. 팩토리 빈 팩토리 빈 - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈임.\n스프링의 FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 됨.\ncode(FactoryBean 인터페이스)\npackage org.springframework.beans.factory; public interface FactoryBean\u003cT\u003e { T getObject() throws Exception; // 빈 오브젝트 생성해서 돌려주기 Class\u003c? extends T\u003e getObjectType(); //생성되는 오브젝트 타입 알려주기 boolean isSingleton(); //getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려주기 } 프록시 팩토리 빈 방식의 장점 - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음.\nDI가 중요한 역할을 함. 프록시 팩토리 빈의 한계\n프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일임. 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능함. 하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어려움. DI를 적용해 해결할 수 있을까? 스프링의 프록시 팩토리 빈 ProxyFactoryBean 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈임. TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있음. ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다. MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받음. 따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능함. ProxyFactoryBean의 특징 MethodInvocation 일종의 콜백 오브젝트임. proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있음. ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있음. ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 **addAdvice()**라는 메소드를 사용함. ProxyFactoryBean 하나로 여러 개의 부가 기능을 제공해주는 프록시 만들 수 있음. advice - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트임. 인터페이스 자동 검출 기능 JDK 다이내믹 프록시의 경우 Hello 인터페이스를 통해 다이내믹 프록시 오브젝트의 타입을 결정함. 인터페이스를 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄. 타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이 있음. 포인트 컷 기존에 InvocationHandler를 직접 구현했을 때는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정하는 것이 있었음. 스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까? 불가능함. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 됨. 어떻게 해결할까? MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남긴다. 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣음. 스프링의 ProxyFactoryBean 방식은 **부가기능(advice)과 메소드 선정 알고리즘(pointcut)**을 활용하는 유연한 구조 제공. advice - 부가기능을 제공하는 오브젝트 pointcut - 메소드 선정 알고리즘을 담은 오브젝트 어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용됨. 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조임. 어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능) 어드바이스와 포인트컷의 재사용 UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있음. 메소드의 선정을 위한 포인트 컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록하면 됨. 스프링 AOP 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해야 함. 중복을 제거할 방법은 없을까? 자동 프록시 생성 빈 후처리기 DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기임. 자동 프록시 생성 빈 후처리기 - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록 가능함. 적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있음. 빈 후처리기는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트 컷이 필요함. 포인트컷 표현식 세밀한 기준을 이용해 클래스나 메소드를 선정하게 하려면 어떻게 해야할까? → (AspectJ) 포인트컷 표현식 사용 정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 함. AspectJExpressionPointcut 클래스를 사용 - 클래스와 메소드의 선정 알고리즘을 포인트 컷 표현식을 이용해 한 번에 지정할 수 있게 해줌. execution() 포인트컷 지시자를 이용한 포인트컷 표현식 문법. execution([접근제한자 패턴] 타입패턴 [타입패턴.] 이름패턴 (타입패턴 | \"..\", ...)[throws 예외 패턴]) (\\* []괄호는 옵션이므로 생략가능함.) [접근제한자 패턴] : public, private과 같은 접근제한자. 타입 패턴 : 리턴 값의 타입 패턴 [타입패턴.] : 패키지와 클래스 이름에 대한 패턴 이름패턴 : 메소드 이름 패턴 (타입패턴 | “..”, …) : 파라미터의 타입 패턴을 순서대로 넣음. 부가기능의 모듈화 비즈니스 로직을 담은 UserService에 트랜잭션을 적용한 과정 트랜잭션 서비스 추상화 : 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣음. → 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용 프록시와 데코레이터 패턴 : 트랜잭션이라는 부가적인 기능을 어디에 적용할 것인가는 코드에 노출되어 있음. → DI를 이용해 데코레이터 패턴 적용. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었음. 다이내믹 프록시와 프록시 팩토리 빈 : 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업은 오히려 큰 짐임. → JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI 도입. 자동 프록시 생성 방법과 포인트컷 : 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해야 함. → 빈 생성 후처리 기법 활용. 프록시를 적용할 대상을 일일이 지정하지 않도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷 사용함. 부가기능의 모듈화 트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로 모듈화하기 힘들다. 부가기능이기 때문에 독립적인 방식으로 존재해서는 적용되기 어려움. 어떻게 부가기능을 독립적인 모듈로 만들 수 있을까? DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법은 이 문제를 해결하기 위한 방법. AOP 애스펙트(aspect): 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈임. 어드바이스: 부가될 기능을 정의 포인트컷 : 어디바이스를 어디에 적용할지 결정 Aspect Oriented Programming: 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법임. 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것임. → 관점 지향 프로그래밍이라고도 함. OOP를 돕는 보조적인 기술임. 프록시를 이용한 AOP 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고있는 것이 프록시임. 스프링은 프록시 방식의 AOP라고 할 수 있음. AspectJ를 이용한 AOP 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용함. 컴파일된 타깃의 클래스 파일 자체를 수정하거나 바이트코드를 조작함. 용어 타깃 : 부가기능을 부여할 대상임. 어드바이스 : 타깃에게 제공할 부가기능을 담은 모듈임. 조인 포인트 : 어드바이스가 적용될 수 있는 위치를 말함. 포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈임. 프록시 : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트임. 어드바이저 : 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고있는 AOP의 기본 모듈임. 애스펙트 : 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어짐. AOP 네임스페이스 스프링의 프록시 방식 AOP를 적용하려면 네 가지 빈을 등록해야함. 자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록함. 어드바이스 - 부가기능을 구현한 클래스를 빈으로 등록함. 포인트컷 - AspectJExpressionPointcut을 빈으로 등록함. 어드바이저 - DefaultPointcutAdvisor 클래스를 빈으로 등록함. aop 스키마를 이용해 기계적으로 적용하는 빈들을 간편한 방법으로 등록함. , , aop:advisor 세가지 태그 정의. 트랜잭션 속성 트랜잭션의 경계 안에서 진행된 작업은 commit() or rollback()만 가능함. TransactionDefinition 타입 오브젝트를 사용하면 다음의 네 가지 속성을 이용해 트랜잭션의 동작방식을 제어할 수 있음. 1) 트랜잭션 전파(transaction propagation)\n트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식 트랜잭션 전파 속성 PROPAGATION_REQUIRED - 진행 중인 트랜잭션이 없으면 새로 시작, 이미 시작된 트랜잭션이 있으면 참여 PROPAGATION_REQUIRES_NEW - 항상 새로운 트랜잭션 시작 PROPAGATION_NOT_SUPPORTED - 트랜잭션 없이 동작하도록 만든다. 진행 중인 트랜잭션이 있어도 무시함. 2) 격리수준(isolation level)\n모든 DB 트랜잭션은 격리수준을 갖고 있어야함. 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요함. 3) 제한시간\n트랜잭션을 수행하는 제한시간을 설정할 수 있음. 4) 읽기전용\n읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음. 트랜잭션 인터셉터와 트랜잭션 속성 메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야함. TransactionInterceptor - 스프링이 제공하는 트랜잭션 경계설정 어드바이스 런타임 예외가 발생하면 트랜잭션은 롤백 체크 예외 발생의 경우 트랜잭션은 커밋 rollbackOn() 속성 - 특정 체크 예외의 경우는 트랜잭션 롤백, 특정 런타임 예외에 대해서는 트랜잭션 커밋 Properties 타입의 transactionAttributes 프로퍼티 - 트랜잭션 속성을 정의한 프로퍼티 메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션임. 포인트컷과 트랜잭션 속성의 적용 전략 1) 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용\n(쓰기 작업이 없는) 단순 조회 메소드 → 모두 트랜잭션 적용 조회 메소드→ 읽기전용으로 트랜잭션 속성 설정 복잡한 조회 메소드 → 제한시간 지정 트랜잭션의 경계로 삼을 클래스들 정해지면, 그 클래스들이 모여 있는 패키지를 전부 선택하거나 클래스 이름에서 일정한 패턴을 찾아 표현식으로 만든다. 가능하면 클래스보다는 인터페이스 타입을 기준으로 타입 패턴 적용. 2) 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.\n기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어두면 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있음. 예를 들어 조회의 경우 - get or find를 메소드 명의 접두사로 사용 3) 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.\n타깃 안에서의 호출에는 프록시가 적용되지 않는 문제 해결1) 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제 해결2) AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술 적용 애노테이션 트랜잭션 속성과 포인트컷 세밀한 트랜잭션 속성의 제어가 필요한 경우 → 설정파일에서 패턴으로 분류 가능한 그룹을 만들어서 일괄적으로 속성을 부여하는 대신에 직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정 트랜잭션 애노테이션 @Transactional 이 애노테이션의 타깃은 메소드와 타입임. → 메소드, 클래스, 인터페이스에 사용가능함. 트랜잭션의 속성을 정의하고, 동시에 포인트컷의 자동 등록에도 사용됨. 메소드마다 @Transactional을 부여하고 속성을 지정할 수 있음. 문제) 코드가 지저분해지고, 동일한 속성 정보를 가진 애노테이션을 반복 사용함. → 스프링은 @Transactional을 적용할 때 4단계의 대체 정책을 이용하게 해줌. 메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입의 순서에 따라서 애노테이션이 적용됐는지 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 함. 트랜잭션 지원 테스트 선언적 트랜잭션과 트랜잭션 전파 속성 선언적 트랜잭션(Declarative transaction) - AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법 프로그램에 의한 트랜잭션(Programmatic transaction) - TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에 사용하는 방법 트랜잭션 동기화와 테스트 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있음. 테스트에서 트랜잭션을 시작하거나 조작할 수 있는 기능은 유용함. 롤백 테스트 - 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게하고 테스트가 끝나면 무조건 롤백하는 테스트 테스트를 이용한 트랜잭션 애노테이션 @Transactional 적용하면 테스트 메소드에 트랜잭션 경계가 자동 설정됨. 테스트가 끝나면 자동 롤백 @Rollback 테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶지만 강제 롤백을 원하지 않는 경우 이용함. 롤백 여부를 지정하는 값을 갖고 있으며, 기본 값은 @Rollback(true)임. @TransactionalConfiguration 테스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 모든 트랜잭션이 롤백되지 않고 커밋되게 할 경우 사용함. 클래스 레벨에 부여할 수 있는 애노테이션임. 롤백에 대한 공통 속성을 지정할 수 있음. 효과적인 DB 테스트 단위 테스트와 통합테스트는 클래스를 구분해서 만드는 것이 좋음. 참고 자료 [book] 토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민 ","wordCount":"2200","inLanguage":"en","datePublished":"2023-02-05T04:56:34+09:00","dateModified":"2023-02-05T04:56:34+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/spring/spring_toby_7/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[토비의 스프링 3.1] 6장 정리</h1><div class=post-meta><span title='2023-02-05 04:56:34 +0900 KST'>February 5, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2200 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring/spring_toby_7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#단위-테스트>단위 테스트</a><ul><li><a href=#목-프레임워크>목 프레임워크</a></li></ul></li><li><a href=#다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈</a><ul><li><a href=#데코레이터-패턴>데코레이터 패턴</a></li><li><a href=#프록시-패턴>프록시 패턴</a></li><li><a href=#다이내믹-프록시>다이내믹 프록시</a></li><li><a href=#팩토리-빈>팩토리 빈</a></li></ul></li><li><a href=#스프링의-프록시-팩토리-빈>스프링의 프록시 팩토리 빈</a><ul><li><a href=#proxyfactorybean>ProxyFactoryBean</a></li><li><a href=#proxyfactorybean의-특징>ProxyFactoryBean의 특징</a></li><li><a href=#포인트-컷>포인트 컷</a></li><li><a href=#어드바이스와-포인트컷의-재사용>어드바이스와 포인트컷의 재사용</a></li></ul></li><li><a href=#스프링-aop>스프링 AOP</a><ul><li><a href=#자동-프록시-생성-빈-후처리기>자동 프록시 생성 빈 후처리기</a></li><li><a href=#포인트컷-표현식>포인트컷 표현식</a></li><li><a href=#부가기능의-모듈화>부가기능의 모듈화</a></li><li><a href=#aop>AOP</a></li><li><a href=#aop-네임스페이스>AOP 네임스페이스</a></li></ul></li><li><a href=#트랜잭션-속성>트랜잭션 속성</a><ul><li><a href=#트랜잭션-인터셉터와-트랜잭션-속성>트랜잭션 인터셉터와 트랜잭션 속성</a></li><li><a href=#포인트컷과-트랜잭션-속성의-적용-전략>포인트컷과 트랜잭션 속성의 적용 전략</a></li></ul></li><li><a href=#애노테이션-트랜잭션-속성과-포인트컷>애노테이션 트랜잭션 속성과 포인트컷</a><ul><li><a href=#트랜잭션-애노테이션>트랜잭션 애노테이션</a></li></ul></li><li><a href=#트랜잭션-지원-테스트>트랜잭션 지원 테스트</a><ul><li><a href=#선언적-트랜잭션과-트랜잭션-전파-속성>선언적 트랜잭션과 트랜잭션 전파 속성</a></li><li><a href=#트랜잭션-동기화와-테스트>트랜잭션 동기화와 테스트</a></li><li><a href=#테스트를-이용한-트랜잭션-애노테이션>테스트를 이용한 트랜잭션 애노테이션</a></li><li><a href=#효과적인-db-테스트>효과적인 DB 테스트</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><ul><li>AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임.</li></ul><h2 id=단위-테스트>단위 테스트<a hidden class=anchor aria-hidden=true href=#단위-테스트>#</a></h2><ul><li>작은 단위의 테스트가 더 좋음.
→ 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐.</li><li>테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용</li><li>통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트</li><li>단위테스트 vs. 통합 테스트<ul><li>항상 단위테스트를 먼저 고려함.</li><li>외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다.</li><li>스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임.</li></ul></li><li>코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임.</li></ul><h3 id=목-프레임워크>목 프레임워크<a hidden class=anchor aria-hidden=true href=#목-프레임워크>#</a></h3><ul><li>단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.)</li><li>Mockito 프레임워크<ul><li>목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임.</li><li>mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드</li></ul></li><li>Mockito 사용 단계<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>mockUpgradeLevels</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>UserServiceImpl</span> <span class=n>userServiceImpl</span> <span class=o>=</span> <span class=k>new</span> <span class=n>UserServiceImpl</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>//1) 인터페이스를 이용해 목 오브젝트 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>UserDao</span> <span class=n>mockUserDao</span> <span class=o>=</span> <span class=n>mock</span><span class=o>(</span><span class=n>UserDao</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//2) 목 오브젝트가 리턴할 값이 있으면 지정
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>when</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>.</span><span class=na>getAll</span><span class=o>()).</span><span class=na>thenReturn</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>users</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>userServiceImpl</span><span class=o>.</span><span class=na>setUserDao</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=c1>//4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update() 메소드가 두 번 호출됐는지 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>verify</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>,</span> <span class=n>times</span><span class=o>(</span><span class=n>2</span><span class=o>)).</span><span class=na>update</span><span class=o>(</span><span class=n>any</span><span class=o>(</span><span class=n>User</span><span class=o>.</span><span class=na>class</span><span class=o>));</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></li></ul><h2 id=다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시와-팩토리-빈>#</a></h2><ul><li>프록시 - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것<ul><li>프록시의 특징은 타깃과 같은 인터페이스 구현 & 프록시가 타깃을 제어할 수 있는 위치에 있음</li><li>사용목적에 따른 구분<ul><li><ol><li>클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴</li></ol></li><li><ol start=2><li>타깃에 부가적인 기능 부여 → 데코레이터 패턴</li></ol></li></ul></li></ul></li><li>타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트</li></ul><h3 id=데코레이터-패턴>데코레이터 패턴<a hidden class=anchor aria-hidden=true href=#데코레이터-패턴>#</a></h3><ul><li>타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임.<ul><li>다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음.</li></ul></li><li>데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음.</li><li>프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦.</li><li>타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임.</li></ul><h3 id=프록시-패턴>프록시 패턴<a hidden class=anchor aria-hidden=true href=#프록시-패턴>#</a></h3><ul><li>프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌.</li><li>클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함.</li><li>특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함.</li><li>구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.</li></ul><h3 id=다이내믹-프록시>다이내믹 프록시<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시>#</a></h3><ul><li>다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.<ul><li>클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있음.</li></ul></li><li>java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음.</li><li>프록시의 기능<ul><li>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임</li><li>지정된 요청에 대해서는 부가기능 수행</li></ul></li><li>프록시 만들기가 번거로운 이유<ul><li>타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움.
→ JDK의 다이내믹 프록시로 해결</li><li>부가기능 코드가 중복될 가능성이 있음.</li></ul></li><li>리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임.<ul><li>java.lang.reflect.Method 인터페이스<ul><li>메소드에 대한 자세한 정보를 담고 있음.</li><li>특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌.</li></ul></li></ul></li></ul><h3 id=팩토리-빈>팩토리 빈<a hidden class=anchor aria-hidden=true href=#팩토리-빈>#</a></h3><ul><li><p>팩토리 빈 - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈임.</p></li><li><p>스프링의 FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 됨.</p></li><li><p>code(FactoryBean 인터페이스)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>org.springframework.beans.factory</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>FactoryBean</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=nf>getObject</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span><span class=o>;</span> <span class=c1>// 빈 오브젝트 생성해서 돌려주기
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Class</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>T</span><span class=o>&gt;</span> <span class=nf>getObjectType</span><span class=o>();</span> <span class=c1>//생성되는 오브젝트 타입 알려주기
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>boolean</span> <span class=nf>isSingleton</span><span class=o>();</span> <span class=c1>//getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려주기
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div></li><li><p>프록시 팩토리 빈 방식의 장점 - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음.</p><ul><li>DI가 중요한 역할을 함.</li></ul></li><li><p>프록시 팩토리 빈의 한계</p><ul><li>프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일임. 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능함.</li><li>하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어려움.</li><li>DI를 적용해 해결할 수 있을까?</li></ul></li></ul><h2 id=스프링의-프록시-팩토리-빈>스프링의 프록시 팩토리 빈<a hidden class=anchor aria-hidden=true href=#스프링의-프록시-팩토리-빈>#</a></h2><h3 id=proxyfactorybean>ProxyFactoryBean<a hidden class=anchor aria-hidden=true href=#proxyfactorybean>#</a></h3><ul><li>프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈임.<ul><li>TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있음.</li></ul></li><li>ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.<ul><li>MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받음.</li><li>따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능함.</li></ul></li></ul><h3 id=proxyfactorybean의-특징>ProxyFactoryBean의 특징<a hidden class=anchor aria-hidden=true href=#proxyfactorybean의-특징>#</a></h3><ol><li>MethodInvocation</li></ol><ul><li>일종의 콜백 오브젝트임.</li><li>proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있음.</li><li>ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있음.</li></ul><ol start=2><li>ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 **addAdvice()**라는 메소드를 사용함.</li></ol><ul><li>ProxyFactoryBean 하나로 여러 개의 부가 기능을 제공해주는 프록시 만들 수 있음.</li><li>advice - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트임.</li></ul><ol start=3><li>인터페이스 자동 검출 기능</li></ol><ul><li>JDK 다이내믹 프록시의 경우 Hello 인터페이스를 통해 다이내믹 프록시 오브젝트의 타입을 결정함.</li><li>인터페이스를 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄.</li><li>타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이 있음.</li></ul><h3 id=포인트-컷>포인트 컷<a hidden class=anchor aria-hidden=true href=#포인트-컷>#</a></h3><ul><li>기존에 InvocationHandler를 직접 구현했을 때는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정하는 것이 있었음.</li><li>스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까?<ul><li>불가능함. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 됨.</li><li>어떻게 해결할까?<ul><li>MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남긴다. 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣음.</li></ul></li></ul></li><li>스프링의 ProxyFactoryBean 방식은 **부가기능(advice)과 메소드 선정 알고리즘(pointcut)**을 활용하는 유연한 구조 제공.<ul><li>advice - 부가기능을 제공하는 오브젝트</li><li>pointcut - 메소드 선정 알고리즘을 담은 오브젝트</li><li>어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용됨.</li></ul></li><li>프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조임.</li><li>어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)</li></ul><h3 id=어드바이스와-포인트컷의-재사용>어드바이스와 포인트컷의 재사용<a hidden class=anchor aria-hidden=true href=#어드바이스와-포인트컷의-재사용>#</a></h3><ul><li>UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있음.</li><li>메소드의 선정을 위한 포인트 컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록하면 됨.</li></ul><h2 id=스프링-aop>스프링 AOP<a hidden class=anchor aria-hidden=true href=#스프링-aop>#</a></h2><ul><li>부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해야 함. 중복을 제거할 방법은 없을까?</li></ul><h3 id=자동-프록시-생성-빈-후처리기>자동 프록시 생성 빈 후처리기<a hidden class=anchor aria-hidden=true href=#자동-프록시-생성-빈-후처리기>#</a></h3><ul><li>DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기임.</li><li>자동 프록시 생성 빈 후처리기 - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록 가능함.</li><li>적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있음.</li><li>빈 후처리기는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트 컷이 필요함.</li></ul><h3 id=포인트컷-표현식>포인트컷 표현식<a hidden class=anchor aria-hidden=true href=#포인트컷-표현식>#</a></h3><ul><li>세밀한 기준을 이용해 클래스나 메소드를 선정하게 하려면 어떻게 해야할까? → (AspectJ) 포인트컷 표현식 사용</li><li>정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 함.</li><li>AspectJExpressionPointcut 클래스를 사용 - 클래스와 메소드의 선정 알고리즘을 포인트 컷 표현식을 이용해 한 번에 지정할 수 있게 해줌.</li><li>execution() 포인트컷 지시자를 이용한 포인트컷 표현식 문법.<div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>execution([접근제한자 패턴] 타입패턴 [타입패턴.] 이름패턴 (타입패턴 | &#34;..&#34;, ...)[throws 예외 패턴])
</span></span><span class=line><span class=cl>(\* []괄호는 옵션이므로 생략가능함.)
</span></span></code></pre></div><ul><li>[접근제한자 패턴] : public, private과 같은 접근제한자.</li><li>타입 패턴 : 리턴 값의 타입 패턴</li><li>[타입패턴.] : 패키지와 클래스 이름에 대한 패턴</li><li>이름패턴 : 메소드 이름 패턴</li><li>(타입패턴 | &ldquo;..&rdquo;, &mldr;) : 파라미터의 타입 패턴을 순서대로 넣음.</li></ul></li></ul><h3 id=부가기능의-모듈화>부가기능의 모듈화<a hidden class=anchor aria-hidden=true href=#부가기능의-모듈화>#</a></h3><ul><li>비즈니스 로직을 담은 UserService에 트랜잭션을 적용한 과정<ul><li><ol><li>트랜잭션 서비스 추상화 : 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣음.
→ 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용</li></ol></li><li><ol start=2><li>프록시와 데코레이터 패턴 : 트랜잭션이라는 부가적인 기능을 어디에 적용할 것인가는 코드에 노출되어 있음.
→ DI를 이용해 데코레이터 패턴 적용. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었음.</li></ol></li><li><ol start=3><li>다이내믹 프록시와 프록시 팩토리 빈 : 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업은 오히려 큰 짐임.
→ JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI 도입.</li></ol></li><li><ol start=4><li>자동 프록시 생성 방법과 포인트컷 : 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해야 함.
→ 빈 생성 후처리 기법 활용. 프록시를 적용할 대상을 일일이 지정하지 않도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷 사용함.</li></ol></li></ul></li><li>부가기능의 모듈화<ul><li>트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로 모듈화하기 힘들다. 부가기능이기 때문에 독립적인 방식으로 존재해서는 적용되기 어려움.</li><li>어떻게 부가기능을 독립적인 모듈로 만들 수 있을까?<ul><li>DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법은 이 문제를 해결하기 위한 방법.</li></ul></li></ul></li></ul><h3 id=aop>AOP<a hidden class=anchor aria-hidden=true href=#aop>#</a></h3><ul><li>애스펙트(aspect): 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈임.<ul><li>어드바이스: 부가될 기능을 정의</li><li>포인트컷 : 어디바이스를 어디에 적용할지 결정</li></ul></li><li>Aspect Oriented Programming: 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법임.<ul><li>애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것임. → 관점 지향 프로그래밍이라고도 함.</li><li>OOP를 돕는 보조적인 기술임.</li></ul></li><li>프록시를 이용한 AOP<ul><li>독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고있는 것이 프록시임.</li><li>스프링은 프록시 방식의 AOP라고 할 수 있음.</li></ul></li><li>AspectJ를 이용한 AOP<ul><li>타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용함.</li><li>컴파일된 타깃의 클래스 파일 자체를 수정하거나 바이트코드를 조작함.</li></ul></li><li>용어<ul><li>타깃 : 부가기능을 부여할 대상임.</li><li>어드바이스 : 타깃에게 제공할 부가기능을 담은 모듈임.</li><li>조인 포인트 : 어드바이스가 적용될 수 있는 위치를 말함.</li><li>포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈임.</li><li>프록시 : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트임.</li><li>어드바이저 : 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고있는 AOP의 기본 모듈임.</li><li>애스펙트 : 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어짐.</li></ul></li></ul><h3 id=aop-네임스페이스>AOP 네임스페이스<a hidden class=anchor aria-hidden=true href=#aop-네임스페이스>#</a></h3><ul><li>스프링의 프록시 방식 AOP를 적용하려면 네 가지 빈을 등록해야함.<ul><li>자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록함.</li><li>어드바이스 - 부가기능을 구현한 클래스를 빈으로 등록함.</li><li>포인트컷 - AspectJExpressionPointcut을 빈으로 등록함.</li><li>어드바이저 - DefaultPointcutAdvisor 클래스를 빈으로 등록함.</li></ul></li><li>aop 스키마를 이용해 기계적으로 적용하는 빈들을 간편한 방법으로 등록함.<ul><li>&lt;aop: config>, &lt;aop: pointcut>, <a href=aop:advisor>aop:advisor</a> 세가지 태그 정의.</li></ul></li></ul><h2 id=트랜잭션-속성>트랜잭션 속성<a hidden class=anchor aria-hidden=true href=#트랜잭션-속성>#</a></h2><ul><li>트랜잭션의 경계 안에서 진행된 작업은 commit() or rollback()만 가능함.</li><li>TransactionDefinition 타입 오브젝트를 사용하면 다음의 네 가지 속성을 이용해 트랜잭션의 동작방식을 제어할 수 있음.</li></ul><p><strong>1) 트랜잭션 전파(transaction propagation)</strong></p><ul><li>트랜잭션의 경계에서 <strong>이미 진행 중인 트랜잭션이 있을 때 또는 없을 때</strong> 어떻게 동작할 것인가를 결정하는 방식</li><li>트랜잭션 전파 속성<ul><li>PROPAGATION_REQUIRED - 진행 중인 트랜잭션이 없으면 새로 시작, 이미 시작된 트랜잭션이 있으면 참여</li><li>PROPAGATION_REQUIRES_NEW - 항상 새로운 트랜잭션 시작</li><li>PROPAGATION_NOT_SUPPORTED - 트랜잭션 없이 동작하도록 만든다. 진행 중인 트랜잭션이 있어도 무시함.</li></ul></li></ul><p><strong>2) 격리수준(isolation level)</strong></p><ul><li>모든 DB 트랜잭션은 격리수준을 갖고 있어야함.</li><li>적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요함.</li></ul><p><strong>3) 제한시간</strong></p><ul><li>트랜잭션을 수행하는 제한시간을 설정할 수 있음.</li></ul><p><strong>4) 읽기전용</strong></p><ul><li>읽기전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음.</li></ul><h3 id=트랜잭션-인터셉터와-트랜잭션-속성>트랜잭션 인터셉터와 트랜잭션 속성<a hidden class=anchor aria-hidden=true href=#트랜잭션-인터셉터와-트랜잭션-속성>#</a></h3><ul><li>메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야함.</li><li><strong>TransactionInterceptor</strong> - 스프링이 제공하는 트랜잭션 경계설정 어드바이스<ul><li>런타임 예외가 발생하면 트랜잭션은 롤백</li><li>체크 예외 발생의 경우 트랜잭션은 커밋</li><li>rollbackOn() 속성 - 특정 체크 예외의 경우는 트랜잭션 롤백, 특정 런타임 예외에 대해서는 트랜잭션 커밋</li><li>Properties 타입의 transactionAttributes 프로퍼티 - 트랜잭션 속성을 정의한 프로퍼티<ul><li>메소드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션임.</li></ul></li></ul></li></ul><h3 id=포인트컷과-트랜잭션-속성의-적용-전략>포인트컷과 트랜잭션 속성의 적용 전략<a hidden class=anchor aria-hidden=true href=#포인트컷과-트랜잭션-속성의-적용-전략>#</a></h3><p><strong>1) 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용</strong></p><ul><li>(쓰기 작업이 없는) 단순 조회 메소드 → 모두 트랜잭션 적용</li><li>조회 메소드→ 읽기전용으로 트랜잭션 속성 설정</li><li>복잡한 조회 메소드 → 제한시간 지정</li><li>트랜잭션의 경계로 삼을 클래스들 정해지면, 그 클래스들이 모여 있는 패키지를 전부 선택하거나 클래스 이름에서 일정한 패턴을 찾아 표현식으로 만든다.</li><li>가능하면 클래스보다는 <strong>인터페이스 타입을 기준으로 타입 패턴 적용.</strong></li></ul><p><strong>2) 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.</strong></p><ul><li>기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어두면 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있음.<ul><li>예를 들어 조회의 경우 - get or find를 메소드 명의 접두사로 사용</li></ul></li></ul><p><strong>3) 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.</strong></p><ul><li>타깃 안에서의 호출에는 프록시가 적용되지 않는 문제<ul><li>해결1) 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제</li><li>해결2) AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술 적용</li></ul></li></ul><h2 id=애노테이션-트랜잭션-속성과-포인트컷>애노테이션 트랜잭션 속성과 포인트컷<a hidden class=anchor aria-hidden=true href=#애노테이션-트랜잭션-속성과-포인트컷>#</a></h2><ul><li>세밀한 트랜잭션 속성의 제어가 필요한 경우
→ 설정파일에서 패턴으로 분류 가능한 그룹을 만들어서 일괄적으로 속성을 부여하는 대신에 직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정</li></ul><h3 id=트랜잭션-애노테이션>트랜잭션 애노테이션<a hidden class=anchor aria-hidden=true href=#트랜잭션-애노테이션>#</a></h3><ul><li>@Transactional<ul><li>이 애노테이션의 타깃은 메소드와 타입임. → 메소드, 클래스, 인터페이스에 사용가능함.</li><li>트랜잭션의 속성을 정의하고, 동시에 포인트컷의 자동 등록에도 사용됨.</li><li>메소드마다 @Transactional을 부여하고 속성을 지정할 수 있음.</li><li>문제) 코드가 지저분해지고, 동일한 속성 정보를 가진 애노테이션을 반복 사용함.
→ 스프링은 @Transactional을 적용할 때 4단계의 대체 정책을 이용하게 해줌.
메소드의 속성을 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입의 순서에 따라서 애노테이션이 적용됐는지 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 함.</li></ul></li></ul><h2 id=트랜잭션-지원-테스트>트랜잭션 지원 테스트<a hidden class=anchor aria-hidden=true href=#트랜잭션-지원-테스트>#</a></h2><h3 id=선언적-트랜잭션과-트랜잭션-전파-속성>선언적 트랜잭션과 트랜잭션 전파 속성<a hidden class=anchor aria-hidden=true href=#선언적-트랜잭션과-트랜잭션-전파-속성>#</a></h3><ul><li>선언적 트랜잭션(Declarative transaction) - AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법</li><li>프로그램에 의한 트랜잭션(Programmatic transaction) - TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에 사용하는 방법</li></ul><h3 id=트랜잭션-동기화와-테스트>트랜잭션 동기화와 테스트<a hidden class=anchor aria-hidden=true href=#트랜잭션-동기화와-테스트>#</a></h3><ul><li>스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있음.</li><li>테스트에서 트랜잭션을 시작하거나 조작할 수 있는 기능은 유용함.</li><li>롤백 테스트 - 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게하고 테스트가 끝나면 무조건 롤백하는 테스트</li></ul><h3 id=테스트를-이용한-트랜잭션-애노테이션>테스트를 이용한 트랜잭션 애노테이션<a hidden class=anchor aria-hidden=true href=#테스트를-이용한-트랜잭션-애노테이션>#</a></h3><ul><li>@Transactional<ul><li>적용하면 테스트 메소드에 트랜잭션 경계가 자동 설정됨.</li><li>테스트가 끝나면 자동 롤백</li></ul></li><li>@Rollback<ul><li>테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶지만 <strong>강제 롤백을 원하지 않는 경우</strong> 이용함.</li><li>롤백 여부를 지정하는 값을 갖고 있으며, 기본 값은 @Rollback(true)임.</li></ul></li><li>@TransactionalConfiguration<ul><li>테스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 모든 트랜잭션이 롤백되지 않고 커밋되게 할 경우 사용함.</li><li>클래스 레벨에 부여할 수 있는 애노테이션임. 롤백에 대한 공통 속성을 지정할 수 있음.</li></ul></li></ul><h3 id=효과적인-db-테스트>효과적인 DB 테스트<a hidden class=anchor aria-hidden=true href=#효과적인-db-테스트>#</a></h3><ul><li>단위 테스트와 통합테스트는 클래스를 구분해서 만드는 것이 좋음.</li></ul><h1 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h1><ul><li><a href=https://product.kyobobook.co.kr/detail/S000000935358>[book] <strong>토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/spring/>Spring</a></li><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/javascript/js_1/><span class=title>« Prev</span><br><span>[javascript] 모던 자바스크립트 Deep Dive , 객체 리터럴</span></a>
<a class=next href=http://slow-wave.github.io/post/javascript/js_0/><span class=title>Next »</span><br><span>[javascript] ES6+ 핵심 문법 정리</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>