<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[토비의 스프링 3.1] 6장 정리 | slow-wave blog</title><meta name=keywords content="Spring,Backend,Java"><meta name=description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/spring/spring_toby_7/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[토비의 스프링 3.1] 6장 정리"><meta property="og:description" content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/spring/spring_toby_7/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-05T04:56:34+09:00"><meta property="article:modified_time" content="2023-02-05T04:56:34+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[토비의 스프링 3.1] 6장 정리"><meta name=twitter:description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[토비의 스프링 3.1] 6장 정리","item":"http://slow-wave.github.io/post/spring/spring_toby_7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[토비의 스프링 3.1] 6장 정리","name":"[토비의 스프링 3.1] 6장 정리","description":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs.","keywords":["Spring","Backend","Java"],"articleBody":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs. 통합 테스트 항상 단위테스트를 먼저 고려함. 외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임. 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임. 목 프레임워크 단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.) Mockito 프레임워크 목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임. mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드 Mockito 사용 단계 @Test public void mockUpgradeLevels() throws Exception { UserServiceImpl userServiceImpl = new UserServiceImpl(); //1) 인터페이스를 이용해 목 오브젝트 생성 UserDao mockUserDao = mock(UserDao.class); //2) 목 오브젝트가 리턴할 값이 있으면 지정 //mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴 when(mockUserDao.getAll()).thenReturn(this.users); //3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함. userServiceImpl.setUserDao(mockUserDao); ... //4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다. //update() 메소드가 두 번 호출됐는지 확인 verify(mockUserDao, times(2)).update(any(User.class)); ... } 다이내믹 프록시와 팩토리 빈 프록시 - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것 프록시의 특징은 타깃과 같은 인터페이스 구현 \u0026 프록시가 타깃을 제어할 수 있는 위치에 있음 사용목적에 따른 구분 클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴 타깃에 부가적인 기능 부여 → 데코레이터 패턴 타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트 데코레이터 패턴 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임. 다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음. 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음. 프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦. 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임. 프록시 패턴 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌. 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함. 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함. 구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음. 다이내믹 프록시 다이내맥 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임. 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있으므. java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음. 프록시의 기능 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임 지정된 요청에 대해서는 부가기능 수행 프록시 만들기가 번거로운 이유 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움. → JDK의 다이내믹 프록시로 해결 부가기능 코드가 중복될 가능성이 있음. 리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임. java.lang.reflect.Method 인터페이스 메소드에 대한 자세한 정보를 담고 있음. 특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌. 참고 자료 [book] 토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민 ","wordCount":"530","inLanguage":"en","datePublished":"2023-02-05T04:56:34+09:00","dateModified":"2023-02-05T04:56:34+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/spring/spring_toby_7/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[토비의 스프링 3.1] 6장 정리</h1><div class=post-meta><span title='2023-02-05 04:56:34 +0900 KST'>February 5, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;530 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring/spring_toby_7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#단위-테스트>단위 테스트</a><ul><li><a href=#목-프레임워크>목 프레임워크</a></li></ul></li><li><a href=#다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈</a><ul><li><a href=#데코레이터-패턴>데코레이터 패턴</a></li><li><a href=#프록시-패턴>프록시 패턴</a></li><li><a href=#다이내믹-프록시>다이내믹 프록시</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><ul><li>AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임.</li></ul><h2 id=단위-테스트>단위 테스트<a hidden class=anchor aria-hidden=true href=#단위-테스트>#</a></h2><ul><li>작은 단위의 테스트가 더 좋음.
→ 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐.</li><li>테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용</li><li>통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트</li><li>단위테스트 vs. 통합 테스트<ul><li>항상 단위테스트를 먼저 고려함.</li><li>외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다.</li><li>스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임.</li></ul></li><li>코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임.</li></ul><h3 id=목-프레임워크>목 프레임워크<a hidden class=anchor aria-hidden=true href=#목-프레임워크>#</a></h3><ul><li>단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.)</li><li>Mockito 프레임워크<ul><li>목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임.</li><li>mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드</li></ul></li><li>Mockito 사용 단계<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>mockUpgradeLevels</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>UserServiceImpl</span> <span class=n>userServiceImpl</span> <span class=o>=</span> <span class=k>new</span> <span class=n>UserServiceImpl</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>//1) 인터페이스를 이용해 목 오브젝트 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>UserDao</span> <span class=n>mockUserDao</span> <span class=o>=</span> <span class=n>mock</span><span class=o>(</span><span class=n>UserDao</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//2) 목 오브젝트가 리턴할 값이 있으면 지정
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>when</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>.</span><span class=na>getAll</span><span class=o>()).</span><span class=na>thenReturn</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>users</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>userServiceImpl</span><span class=o>.</span><span class=na>setUserDao</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=c1>//4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update() 메소드가 두 번 호출됐는지 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>verify</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>,</span> <span class=n>times</span><span class=o>(</span><span class=n>2</span><span class=o>)).</span><span class=na>update</span><span class=o>(</span><span class=n>any</span><span class=o>(</span><span class=n>User</span><span class=o>.</span><span class=na>class</span><span class=o>));</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></li></ul><h2 id=다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시와-팩토리-빈>#</a></h2><ul><li>프록시 - 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것<ul><li>프록시의 특징은 타깃과 같은 인터페이스 구현 & 프록시가 타깃을 제어할 수 있는 위치에 있음</li><li>사용목적에 따른 구분<ul><li><ol><li>클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴</li></ol></li><li><ol start=2><li>타깃에 부가적인 기능 부여 → 데코레이터 패턴</li></ol></li></ul></li></ul></li><li>타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트</li></ul><h3 id=데코레이터-패턴>데코레이터 패턴<a hidden class=anchor aria-hidden=true href=#데코레이터-패턴>#</a></h3><ul><li>타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임.<ul><li>다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음.</li></ul></li><li>데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음.</li><li>프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦.</li><li>타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임.</li></ul><h3 id=프록시-패턴>프록시 패턴<a hidden class=anchor aria-hidden=true href=#프록시-패턴>#</a></h3><ul><li>프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌.</li><li>클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함.</li><li>특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함.</li><li>구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.</li></ul><h3 id=다이내믹-프록시>다이내믹 프록시<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시>#</a></h3><ul><li>다이내맥 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.<ul><li>클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있으므.</li></ul></li><li>java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음.</li><li>프록시의 기능<ul><li>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임</li><li>지정된 요청에 대해서는 부가기능 수행</li></ul></li><li>프록시 만들기가 번거로운 이유<ul><li>타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움.
→ JDK의 다이내믹 프록시로 해결</li><li>부가기능 코드가 중복될 가능성이 있음.</li></ul></li><li>리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임.<ul><li>java.lang.reflect.Method 인터페이스<ul><li>메소드에 대한 자세한 정보를 담고 있음.</li><li>특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌.</li></ul></li></ul></li></ul><h1 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h1><ul><li><a href=https://product.kyobobook.co.kr/detail/S000000935358>[book] <strong>토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/spring/>Spring</a></li><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/javascript/js_1/><span class=title>« Prev</span><br><span>[javascript] 모던 자바스크립트 Deep Dive 10장</span></a>
<a class=next href=http://slow-wave.github.io/post/javascript/js_0/><span class=title>Next »</span><br><span>[javascript] ES6+ 핵심 문법 정리</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>