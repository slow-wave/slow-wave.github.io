<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[토비의 스프링 3.1] 6장 정리 | slow-wave blog</title><meta name=keywords content="Spring,Backend,Java"><meta name=description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/spring/spring_toby_7/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[토비의 스프링 3.1] 6장 정리"><meta property="og:description" content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/spring/spring_toby_7/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-05T04:56:34+09:00"><meta property="article:modified_time" content="2023-02-05T04:56:34+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[토비의 스프링 3.1] 6장 정리"><meta name=twitter:description content="Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[토비의 스프링 3.1] 6장 정리","item":"http://slow-wave.github.io/post/spring/spring_toby_7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[토비의 스프링 3.1] 6장 정리","name":"[토비의 스프링 3.1] 6장 정리","description":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs.","keywords":["Spring","Backend","Java"],"articleBody":"Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs. 통합 테스트 항상 단위테스트를 먼저 고려함. 외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임. 코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임. 목 프레임워크 단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.) Mockito 프레임워크 목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임. mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드 Mockito 사용 단계 @Test public void mockUpgradeLevels() throws Exception { UserServiceImpl userServiceImpl = new UserServiceImpl(); //1) 인터페이스를 이용해 목 오브젝트 생성 UserDao mockUserDao = mock(UserDao.class); //2) 목 오브젝트가 리턴할 값이 있으면 지정 //mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴 when(mockUserDao.getAll()).thenReturn(this.users); //3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함. userServiceImpl.setUserDao(mockUserDao); ... //4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다. //update() 메소드가 두 번 호출됐는지 확인 verify(mockUserDao, times(2)).update(any(User.class)); ... } 다이내믹 프록시와 팩토리 빈 프록시 - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것 프록시의 특징은 타깃과 같은 인터페이스 구현 \u0026 프록시가 타깃을 제어할 수 있는 위치에 있음 사용목적에 따른 구분 클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴 타깃에 부가적인 기능 부여 → 데코레이터 패턴 타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트 데코레이터 패턴 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임. 다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음. 데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음. 프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦. 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임. 프록시 패턴 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌. 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함. 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함. 구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음. 다이내믹 프록시 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임. 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있음. java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음. 프록시의 기능 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임 지정된 요청에 대해서는 부가기능 수행 프록시 만들기가 번거로운 이유 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움. → JDK의 다이내믹 프록시로 해결 부가기능 코드가 중복될 가능성이 있음. 리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임. java.lang.reflect.Method 인터페이스 메소드에 대한 자세한 정보를 담고 있음. 특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌. 팩토리 빈 팩토리 빈 - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈임.\n스프링의 FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 됨.\ncode(FactoryBean 인터페이스)\npackage org.springframework.beans.factory; public interface FactoryBean\u003cT\u003e { T getObject() throws Exception; // 빈 오브젝트 생성해서 돌려주기 Class\u003c? extends T\u003e getObjectType(); //생성되는 오브젝트 타입 알려주기 boolean isSingleton(); //getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려주기 } 프록시 팩토리 빈 방식의 장점 - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음.\nDI가 중요한 역할을 함. 프록시 팩토리 빈의 한계\n프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일임. 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능함. 하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어려움. DI를 적용해 해결할 수 있을까? 스프링의 프록시 팩토리 빈 ProxyFactoryBean 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈임. TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있음. ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다. MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받음. 따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능함. ProxyFactoryBean의 특징 MethodInvocation 일종의 콜백 오브젝트임. proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있음. ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있음. ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 **addAdvice()**라는 메소드를 사용함. ProxyFactoryBean 하나로 여러 개의 부가 기능을 제공해주는 프록시 만들 수 있음. advice - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트임. 인터페이스 자동 검출 기능 JDK 다이내믹 프록시의 경우 Hello 인터페이스를 통해 다이내믹 프록시 오브젝트의 타입을 결정함. 인터페이스를 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄. 타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이 있음. 포인트 컷 기존에 InvocationHandler를 직접 구현했을 때는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정하는 것이 있었음. 스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까? 불가능함. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 됨. 어떻게 해결할까? MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남긴다. 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣음. 스프링의 ProxyFactoryBean 방식은 **부가기능(advice)과 메소드 선정 알고리즘(pointcut)**을 활용하는 유연한 구조 제공. advice - 부가기능을 제공하는 오브젝트 pointcut - 메소드 선정 알고리즘을 담은 오브젝트 어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용됨. 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조임. 어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능) 어드바이스와 포인트컷의 재사용 UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있음. 메소드의 선정을 위한 포인트 컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록하면 됨. 스프링 AOP 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해야 함. 중복을 제거할 방법은 없을까? 자동 프록시 생성 빈 후처리기 DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기임. 자동 프록시 생성 빈 후처리기 - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록 가능함. 적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있음. 빈 후처리기는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트 컷이 필요함. 포인트컷 표현식 세밀한 기준을 이용해 클래스나 메소드를 선정하게 하려면 어떻게 해야할까? → (AspectJ) 포인트컷 표현식 사용 정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 함. AspectJExpressionPointcut 클래스를 사용 - 클래스와 메소드의 선정 알고리즘을 포인트 컷 표현식을 이용해 한 번에 지정할 수 있게 해줌. execution() 포인트컷 지시자를 이용한 포인트컷 표현식 문법. execution([접근제한자 패턴] 타입패턴 [타입패턴.] 이름패턴 (타입패턴 | \"..\", ...)[throws 예외 패턴]) (\\* []괄호는 옵션이므로 생략가능함.) [접근제한자 패턴] : public, private과 같은 접근제한자. 타입 패턴 : 리턴 값의 타입 패턴 [타입패턴.] : 패키지와 클래스 이름에 대한 패턴 이름패턴 : 메소드 이름 패턴 (타입패턴 | “..”, …) : 파라미터의 타입 패턴을 순서대로 넣음. 부가기능의 모듈화 비즈니스 로직을 담은 UserService에 트랜잭션을 적용한 과정 트랜잭션 서비스 추상화 : 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣음. → 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용 프록시와 데코레이터 패턴 : 트랜잭션이라는 부가적인 기능을 어디에 적용할 것인가는 코드에 노출되어 있음. → DI를 이용해 데코레이터 패턴 적용. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었음. 다이내믹 프록시와 프록시 팩토리 빈 : 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업은 오히려 큰 짐임. → JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI 도입. 자동 프록시 생성 방법과 포인트컷 : 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해야 함. → 빈 생성 후처리 기법 활용. 프록시를 적용할 대상을 일일이 지정하지 않도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷 사용함. 부가기능의 모듈화 트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로 모듈화하기 힘들다. 부가기능이기 때문에 독립적인 방식으로 존재해서는 적용되기 어려움. 어떻게 부가기능을 독립적인 모듈로 만들 수 있을까? DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법은 이 문제를 해결하기 위한 방법. AOP 애스펙트(aspect): 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈임. 어드바이스: 부가될 기능을 정의 포인트컷 : 어디바이스를 어디에 적용할지 결정 Aspect Oriented Programming: 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법임. 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것임. → 관점 지향 프로그래밍이라고도 함. OOP를 돕는 보조적인 기술임. 프록시를 이용한 AOP 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고있는 것이 프록시임. 스프링은 프록시 방식의 AOP라고 할 수 있음. AspectJ를 이용한 AOP 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용함. 컴파일된 타깃의 클래스 파일 자체를 수정하거나 바이트코드를 조작함. 용어 타깃 : 부가기능을 부여할 대상임. 어드바이스 : 타깃에게 제공할 부가기능을 담은 모듈임. 조인 포인트 : 어드바이스가 적용될 수 있는 위치를 말함. 포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈임. 프록시 : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트임. 어드바이저 : 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고있는 AOP의 기본 모듈임. 애스펙트 : 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어짐. AOP 네임스페이스 스프링의 프록시 방식 AOP를 적용하려면 네 가지 빈을 등록해야함. 자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록함. 어드바이스 - 부가기능을 구현한 클래스를 빈으로 등록함. 포인트컷 - AspectJExpressionPointcut을 빈으로 등록함. 어드바이저 - DefaultPointcutAdvisor 클래스를 빈으로 등록함. aop 스키마를 이용해 기계적으로 적용하는 빈들을 간편한 방법으로 등록함. , , aop:advisor 세가지 태그 정의. 참고 자료 [book] 토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민 ","wordCount":"1592","inLanguage":"en","datePublished":"2023-02-05T04:56:34+09:00","dateModified":"2023-02-05T04:56:34+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/spring/spring_toby_7/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[토비의 스프링 3.1] 6장 정리</h1><div class=post-meta><span title='2023-02-05 04:56:34 +0900 KST'>February 5, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1592 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring/spring_toby_7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#단위-테스트>단위 테스트</a><ul><li><a href=#목-프레임워크>목 프레임워크</a></li></ul></li><li><a href=#다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈</a><ul><li><a href=#데코레이터-패턴>데코레이터 패턴</a></li><li><a href=#프록시-패턴>프록시 패턴</a></li><li><a href=#다이내믹-프록시>다이내믹 프록시</a></li><li><a href=#팩토리-빈>팩토리 빈</a></li></ul></li><li><a href=#스프링의-프록시-팩토리-빈>스프링의 프록시 팩토리 빈</a><ul><li><a href=#proxyfactorybean>ProxyFactoryBean</a></li><li><a href=#proxyfactorybean의-특징>ProxyFactoryBean의 특징</a></li><li><a href=#포인트-컷>포인트 컷</a></li><li><a href=#어드바이스와-포인트컷의-재사용>어드바이스와 포인트컷의 재사용</a></li></ul></li><li><a href=#스프링-aop>스프링 AOP</a><ul><li><a href=#자동-프록시-생성-빈-후처리기>자동 프록시 생성 빈 후처리기</a></li><li><a href=#포인트컷-표현식>포인트컷 표현식</a></li><li><a href=#부가기능의-모듈화>부가기능의 모듈화</a></li><li><a href=#aop>AOP</a></li><li><a href=#aop-네임스페이스>AOP 네임스페이스</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><ul><li>AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임.</li></ul><h2 id=단위-테스트>단위 테스트<a hidden class=anchor aria-hidden=true href=#단위-테스트>#</a></h2><ul><li>작은 단위의 테스트가 더 좋음.
→ 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐.</li><li>테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용</li><li>통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트</li><li>단위테스트 vs. 통합 테스트<ul><li>항상 단위테스트를 먼저 고려함.</li><li>외부 리소스 사용해야만 가능한 테스트는 통합 테스트로만든다.</li><li>스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트임.</li></ul></li><li>코드를 작성하면서 테스트는 어떻게 만들 수 있을까를 생각해보는 것은 좋은 습관임.</li></ul><h3 id=목-프레임워크>목 프레임워크<a hidden class=anchor aria-hidden=true href=#목-프레임워크>#</a></h3><ul><li>단위 테스트를 만들기위해서는 스텁이나 목 오브젝트의 사용이 필수적임. → 단위 테스트를 만들 때 목 오브젝트를 만드는 것은 번거로운 일임. (테스트에서 사용하지 않는 인터페이스도 구현해야 함.)</li><li>Mockito 프레임워크<ul><li>목 오브젝트를 편리하게 작성하도록 도와주는 프레임워크임.</li><li>mock() 메소드 - org.mockito.Matchers 클래스의 스태틱 메소드</li></ul></li><li>Mockito 사용 단계<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>mockUpgradeLevels</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>UserServiceImpl</span> <span class=n>userServiceImpl</span> <span class=o>=</span> <span class=k>new</span> <span class=n>UserServiceImpl</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>//1) 인터페이스를 이용해 목 오브젝트 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>UserDao</span> <span class=n>mockUserDao</span> <span class=o>=</span> <span class=n>mock</span><span class=o>(</span><span class=n>UserDao</span><span class=o>.</span><span class=na>class</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//2) 목 오브젝트가 리턴할 값이 있으면 지정
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//mockUserDao.getAll()이 호출됐을 때, users 리스트 리턴
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>when</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>.</span><span class=na>getAll</span><span class=o>()).</span><span class=na>thenReturn</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>users</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//3) 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 함.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>userServiceImpl</span><span class=o>.</span><span class=na>setUserDao</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=c1>//4) 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지, 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//update() 메소드가 두 번 호출됐는지 확인
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>verify</span><span class=o>(</span><span class=n>mockUserDao</span><span class=o>,</span> <span class=n>times</span><span class=o>(</span><span class=n>2</span><span class=o>)).</span><span class=na>update</span><span class=o>(</span><span class=n>any</span><span class=o>(</span><span class=n>User</span><span class=o>.</span><span class=na>class</span><span class=o>));</span>
</span></span><span class=line><span class=cl>	<span class=o>...</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></li></ul><h2 id=다이내믹-프록시와-팩토리-빈>다이내믹 프록시와 팩토리 빈<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시와-팩토리-빈>#</a></h2><ul><li>프록시 - 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것<ul><li>프록시의 특징은 타깃과 같은 인터페이스 구현 & 프록시가 타깃을 제어할 수 있는 위치에 있음</li><li>사용목적에 따른 구분<ul><li><ol><li>클라이언트가 타깃에 접근하는 방법 제어 → 프록시 패턴</li></ol></li><li><ol start=2><li>타깃에 부가적인 기능 부여 → 데코레이터 패턴</li></ol></li></ul></li></ul></li><li>타깃(target) or 실체(real subject) - 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트</li></ul><h3 id=데코레이터-패턴>데코레이터 패턴<a hidden class=anchor aria-hidden=true href=#데코레이터-패턴>#</a></h3><ul><li>타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴임.<ul><li>다이내믹하게 기능을 부가한다? 컴파일시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져있지 않음.</li></ul></li><li>데코레이터 패턴에서는 같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용할 수 있음.</li><li>프록시가 여러 개이므로 순서를 정해서 단계적으로 위임하는 구조로 만듦.</li><li>타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법임.</li></ul><h3 id=프록시-패턴>프록시 패턴<a hidden class=anchor aria-hidden=true href=#프록시-패턴>#</a></h3><ul><li>프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경해줌.</li><li>클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공함.</li><li>특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위해 사용함.</li><li>구조적으로 보면 데코레이터와 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.</li></ul><h3 id=다이내믹-프록시>다이내믹 프록시<a hidden class=anchor aria-hidden=true href=#다이내믹-프록시>#</a></h3><ul><li>다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.<ul><li>클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있음.</li></ul></li><li>java.lang.reflect 패키지 - 프록시를 쉽게 만들도록 지원해주는 클래스들이 있음.</li><li>프록시의 기능<ul><li>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임</li><li>지정된 요청에 대해서는 부가기능 수행</li></ul></li><li>프록시 만들기가 번거로운 이유<ul><li>타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 어려움.
→ JDK의 다이내믹 프록시로 해결</li><li>부가기능 코드가 중복될 가능성이 있음.</li></ul></li><li>리플렉션 - 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어줌. 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것임.<ul><li>java.lang.reflect.Method 인터페이스<ul><li>메소드에 대한 자세한 정보를 담고 있음.</li><li>특정 오브젝트의 메소드 실행 가능 → invoke() 메소드, 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌.</li></ul></li></ul></li></ul><h3 id=팩토리-빈>팩토리 빈<a hidden class=anchor aria-hidden=true href=#팩토리-빈>#</a></h3><ul><li><p>팩토리 빈 - 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈임.</p></li><li><p>스프링의 FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 됨.</p></li><li><p>code(FactoryBean 인터페이스)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>package</span> <span class=nn>org.springframework.beans.factory</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>FactoryBean</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>T</span> <span class=nf>getObject</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span><span class=o>;</span> <span class=c1>// 빈 오브젝트 생성해서 돌려주기
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Class</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>T</span><span class=o>&gt;</span> <span class=nf>getObjectType</span><span class=o>();</span> <span class=c1>//생성되는 오브젝트 타입 알려주기
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>boolean</span> <span class=nf>isSingleton</span><span class=o>();</span> <span class=c1>//getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려주기
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>}</span>
</span></span></code></pre></div></li><li><p>프록시 팩토리 빈 방식의 장점 - 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있음.</p><ul><li>DI가 중요한 역할을 함.</li></ul></li><li><p>프록시 팩토리 빈의 한계</p><ul><li>프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일임. 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 불가능함.</li><li>하나의 타깃에 여러 개의 부가기능을 적용하는 것도 어려움.</li><li>DI를 적용해 해결할 수 있을까?</li></ul></li></ul><h2 id=스프링의-프록시-팩토리-빈>스프링의 프록시 팩토리 빈<a hidden class=anchor aria-hidden=true href=#스프링의-프록시-팩토리-빈>#</a></h2><h3 id=proxyfactorybean>ProxyFactoryBean<a hidden class=anchor aria-hidden=true href=#proxyfactorybean>#</a></h3><ul><li>프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈임.<ul><li>TxProxyFactoryBean과 달리, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있음.</li></ul></li><li>ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.<ul><li>MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받음.</li><li>따라서 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고, 싱글톤 빈으로 등록 가능함.</li></ul></li></ul><h3 id=proxyfactorybean의-특징>ProxyFactoryBean의 특징<a hidden class=anchor aria-hidden=true href=#proxyfactorybean의-특징>#</a></h3><ol><li>MethodInvocation</li></ol><ul><li>일종의 콜백 오브젝트임.</li><li>proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있음.</li><li>ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있음.</li></ul><ol start=2><li>ProxyFactoryBean에 이 MethodInterceptor를 설정해 줄 때는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 **addAdvice()**라는 메소드를 사용함.</li></ol><ul><li>ProxyFactoryBean 하나로 여러 개의 부가 기능을 제공해주는 프록시 만들 수 있음.</li><li>advice - MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트. 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트임.</li></ul><ol start=3><li>인터페이스 자동 검출 기능</li></ol><ul><li>JDK 다이내믹 프록시의 경우 Hello 인터페이스를 통해 다이내믹 프록시 오브젝트의 타입을 결정함.</li><li>인터페이스를 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄.</li><li>타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이 있음.</li></ul><h3 id=포인트-컷>포인트 컷<a hidden class=anchor aria-hidden=true href=#포인트-컷>#</a></h3><ul><li>기존에 InvocationHandler를 직접 구현했을 때는 메소드의 이름을 가지고 부가기능을 적용할 대상 메소드를 선정하는 것이 있었음.</li><li>스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까?<ul><li>불가능함. 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 됨.</li><li>어떻게 해결할까?<ul><li>MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남긴다. 대신 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣음.</li></ul></li></ul></li><li>스프링의 ProxyFactoryBean 방식은 **부가기능(advice)과 메소드 선정 알고리즘(pointcut)**을 활용하는 유연한 구조 제공.<ul><li>advice - 부가기능을 제공하는 오브젝트</li><li>pointcut - 메소드 선정 알고리즘을 담은 오브젝트</li><li>어드바이스와 포인트 컷은 모두 프록시에 DI로 주입돼서 사용됨.</li></ul></li><li>프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조임.</li><li>어드바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)</li></ul><h3 id=어드바이스와-포인트컷의-재사용>어드바이스와 포인트컷의 재사용<a hidden class=anchor aria-hidden=true href=#어드바이스와-포인트컷의-재사용>#</a></h3><ul><li>UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있음.</li><li>메소드의 선정을 위한 포인트 컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록하면 됨.</li></ul><h2 id=스프링-aop>스프링 AOP<a hidden class=anchor aria-hidden=true href=#스프링-aop>#</a></h2><ul><li>부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해야 함. 중복을 제거할 방법은 없을까?</li></ul><h3 id=자동-프록시-생성-빈-후처리기>자동 프록시 생성 빈 후처리기<a hidden class=anchor aria-hidden=true href=#자동-프록시-생성-빈-후처리기>#</a></h3><ul><li>DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기임.</li><li>자동 프록시 생성 빈 후처리기 - 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록 가능함.</li><li>적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있음.</li><li>빈 후처리기는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트 컷이 필요함.</li></ul><h3 id=포인트컷-표현식>포인트컷 표현식<a hidden class=anchor aria-hidden=true href=#포인트컷-표현식>#</a></h3><ul><li>세밀한 기준을 이용해 클래스나 메소드를 선정하게 하려면 어떻게 해야할까? → (AspectJ) 포인트컷 표현식 사용</li><li>정규식이나 JSP의 EL과 비슷한 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 함.</li><li>AspectJExpressionPointcut 클래스를 사용 - 클래스와 메소드의 선정 알고리즘을 포인트 컷 표현식을 이용해 한 번에 지정할 수 있게 해줌.</li><li>execution() 포인트컷 지시자를 이용한 포인트컷 표현식 문법.<div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>execution([접근제한자 패턴] 타입패턴 [타입패턴.] 이름패턴 (타입패턴 | &#34;..&#34;, ...)[throws 예외 패턴])
</span></span><span class=line><span class=cl>(\* []괄호는 옵션이므로 생략가능함.)
</span></span></code></pre></div><ul><li>[접근제한자 패턴] : public, private과 같은 접근제한자.</li><li>타입 패턴 : 리턴 값의 타입 패턴</li><li>[타입패턴.] : 패키지와 클래스 이름에 대한 패턴</li><li>이름패턴 : 메소드 이름 패턴</li><li>(타입패턴 | &ldquo;..&rdquo;, &mldr;) : 파라미터의 타입 패턴을 순서대로 넣음.</li></ul></li></ul><h3 id=부가기능의-모듈화>부가기능의 모듈화<a hidden class=anchor aria-hidden=true href=#부가기능의-모듈화>#</a></h3><ul><li>비즈니스 로직을 담은 UserService에 트랜잭션을 적용한 과정<ul><li><ol><li>트랜잭션 서비스 추상화 : 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣음.
→ 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법 적용</li></ol></li><li><ol start=2><li>프록시와 데코레이터 패턴 : 트랜잭션이라는 부가적인 기능을 어디에 적용할 것인가는 코드에 노출되어 있음.
→ DI를 이용해 데코레이터 패턴 적용. 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만들었음.</li></ol></li><li><ol start=3><li>다이내믹 프록시와 프록시 팩토리 빈 : 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업은 오히려 큰 짐임.
→ JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI 도입.</li></ol></li><li><ol start=4><li>자동 프록시 생성 방법과 포인트컷 : 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해야 함.
→ 빈 생성 후처리 기법 활용. 프록시를 적용할 대상을 일일이 지정하지 않도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷 사용함.</li></ol></li></ul></li><li>부가기능의 모듈화<ul><li>트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로 모듈화하기 힘들다. 부가기능이기 때문에 독립적인 방식으로 존재해서는 적용되기 어려움.</li><li>어떻게 부가기능을 독립적인 모듈로 만들 수 있을까?<ul><li>DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법은 이 문제를 해결하기 위한 방법.</li></ul></li></ul></li></ul><h3 id=aop>AOP<a hidden class=anchor aria-hidden=true href=#aop>#</a></h3><ul><li>애스펙트(aspect): 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈임.<ul><li>어드바이스: 부가될 기능을 정의</li><li>포인트컷 : 어디바이스를 어디에 적용할지 결정</li></ul></li><li>Aspect Oriented Programming: 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법임.<ul><li>애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어주는 것임. → 관점 지향 프로그래밍이라고도 함.</li><li>OOP를 돕는 보조적인 기술임.</li></ul></li><li>프록시를 이용한 AOP<ul><li>독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고있는 것이 프록시임.</li><li>스프링은 프록시 방식의 AOP라고 할 수 있음.</li></ul></li><li>AspectJ를 이용한 AOP<ul><li>타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용함.</li><li>컴파일된 타깃의 클래스 파일 자체를 수정하거나 바이트코드를 조작함.</li></ul></li><li>용어<ul><li>타깃 : 부가기능을 부여할 대상임.</li><li>어드바이스 : 타깃에게 제공할 부가기능을 담은 모듈임.</li><li>조인 포인트 : 어드바이스가 적용될 수 있는 위치를 말함.</li><li>포인트컷 : 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈임.</li><li>프록시 : 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트임.</li><li>어드바이저 : 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고있는 AOP의 기본 모듈임.</li><li>애스펙트 : 한개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어짐.</li></ul></li></ul><h3 id=aop-네임스페이스>AOP 네임스페이스<a hidden class=anchor aria-hidden=true href=#aop-네임스페이스>#</a></h3><ul><li>스프링의 프록시 방식 AOP를 적용하려면 네 가지 빈을 등록해야함.<ul><li>자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록함.</li><li>어드바이스 - 부가기능을 구현한 클래스를 빈으로 등록함.</li><li>포인트컷 - AspectJExpressionPointcut을 빈으로 등록함.</li><li>어드바이저 - DefaultPointcutAdvisor 클래스를 빈으로 등록함.</li></ul></li><li>aop 스키마를 이용해 기계적으로 적용하는 빈들을 간편한 방법으로 등록함.<ul><li>&lt;aop: config>, &lt;aop: pointcut>, <a href=aop:advisor>aop:advisor</a> 세가지 태그 정의.</li></ul></li></ul><h1 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h1><ul><li><a href=https://product.kyobobook.co.kr/detail/S000000935358>[book] <strong>토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/spring/>Spring</a></li><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/javascript/js_1/><span class=title>« Prev</span><br><span>[javascript] 모던 자바스크립트 Deep Dive , 객체 리터럴</span></a>
<a class=next href=http://slow-wave.github.io/post/javascript/js_0/><span class=title>Next »</span><br><span>[javascript] ES6+ 핵심 문법 정리</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>