<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[토비의 스프링 3.1] 3장 정리 | slow-wave blog</title><meta name=keywords content="Spring,Backend,Java"><meta name=description content="Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/spring/spring_toby_3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[토비의 스프링 3.1] 3장 정리"><meta property="og:description" content="Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/spring/spring_toby_3/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-18T00:13:50+09:00"><meta property="article:modified_time" content="2022-12-18T00:13:50+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[토비의 스프링 3.1] 3장 정리"><meta name=twitter:description content="Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[토비의 스프링 3.1] 3장 정리","item":"http://slow-wave.github.io/post/spring/spring_toby_3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[토비의 스프링 3.1] 3장 정리","name":"[토비의 스프링 3.1] 3장 정리","description":"Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함.","keywords":["Spring","Backend","Java"],"articleBody":"Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함.) 일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리함. getConnection()으로 가져간 커넥션을 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있음. Connection, PreparedStatement close() 메소드 - 만들어진 걸 종료하는 것이라고 볼 수 있지만 보통 리소스를 반환한다는 의미로 이해하는 것이 좋음. 풀 방식으로 운영됨. (미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할 때 할당, 반환하면 다시 풀에 넣는 방식임.) 요청이 매우 서버 환경에서는 풀 방식 선호. JDBC 코드에서는 리소스를 반환하도록 try/catch/finally 구문 사용을 권장함. 3.2 변하는 것과 변하지 않는 것 3.2.1 JDBC try/catch/finally 코드의 문제점 코드가 복잡하고 중첩되어 있음. → 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 분리\n3.2.2 분리와 재사용을 위한 디자인 패턴 적용 템플릿 메소드 패턴의 적용\n상속을 통해 기능 확장해서 사용. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것임. 문제점 DAO 로직마다 상속 통해 새로운 클래스 만들어야함. 확장구조가 클래스를 설계하는 시점에서 고정되어 버림. 전략 패턴의 적용\n개방폐쇄원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴임. DI 적용을 위한 클라이언트/컨텍스트 분리\n전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적임. DI란 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조임. 마이크로 DI DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것임. DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고 함. 3.3 JDBC 전략 패턴의 최적화 문제 상황\nDAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 함. → 클래스 파일의 수 증가 DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 함. 3.3.2 전략과 클라이언트의 동거 로컬 클래스\n해결법 - StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의하기. 중첩 클래스(nested class)의 종류 스태틱 클래스 - 독립적으로 오브젝트로 만들어질 수 있음. 내부 클래스 - 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음. 범위에 따라 구분 멤버 내부 클래스 - 멤버 필드처럼 오브젝트 레벨에 정의 로컬 클래스 - 메소드 레벨에 정의 익명 내부 클래스 - 이름을 갖지 않는 클래스. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용함. 3.4 컨텍스트와 DI 3.4.2 JDBCContext의 특별한 DI 스프링 빈으로 DI\n인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있지 않을까? 스프링 DI의 기본 의도에 맞게 JdbcContext의 메소드를 인터페이스를 뽑아내어 정의해두고, 이를 UserDao에서 사용해야 하지 않을까? 꼭 인터페이스 사용안해도 됨. 스프링의 DI는 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 개념을 포괄함. → JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입했다는 건 DI 따른 것임. JdbcContext를 UserDao와 DI 구조로 만들어야 할 이유 JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤빈이 되기 때문임. JdbcContext가 DI를 통해 다른 빈에 의존하고 있음. DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 함. 클래스를 바로 사용하는 코드 구성을 DI에 적용하는 것은 가장 마지막 단계에서 고려해볼 사항임. 장점 - 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러남. 단점 - DI의 근본적인 원칙에 부합하지 않은 구체적인 클래스와의 관계가 설정에 직접 노출됨. 코드를 이용하는 수동 DI\n장점 - JdbcContext가 UserDao의 내부에서 만들어지고 사용되면서 관계를 외부에는 드러내지 않아도 됨. 단점 - JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요함. 3.5 템플릿과 콜백 템플릿/콜백 패턴 템플릿 - 전략 패턴의 컨텍스트 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이루어짐. 콜백 - 익명 내부 클래스로 만들어지는 오브젝트 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말함. 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용함. 3.5.1 템플릿/콜백의 동작원리 템플릿/콜백의 특징\n템플릿/콜백의 작업 흐름 [1] 클라이언트는 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트 생성. (콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달함.) [2] 클라이언트는 콜백 전달 및 template 호출 [3] 템플릿 workflow 시작 [4] 템플릿은 참조 정보 생성 [5] 템플릿은 콜백 오브젝트의 메소드를 호출함. [6] 콜백은 client final 변수를 참조 [7] 콜백은 참조정보를 이용해 작업 수행 [8] 콜백은 콜백 작업 결과를 템플릿에 돌려줌. [9] 템플릿은 콜백이 돌려준 정보를 사용해 작업 마저 수행 [10] 템플릿은 경우에 따라 최종결과를 클라이언트에 돌려줌. 템플릿/콜백 방식의 특징 콜백은 단일 메소드 인터페이스를 사용함. 콜백 인터페이스의 메소드에는 보통 파라미터가 있음. 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용됨 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받음. 일반 DI라면 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용함. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조. 클라이언트와 콜백이 강하게 결합됨. 템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법임. 3.5.3 템플릿/콜백의 응용 스프링의 기본이 되는 전략 패턴과 DI는 물론이고 템플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다. 고정된 작업 흐름을 갖고 있으면서 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자. 가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드임. 중복의 제거와 템플릿/콜백 설계\n템플릿에 담을 작업 흐름은 어떤 것인지 살펴보기. 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇인가? 콜백이 템플릿에게 돌려줄 내용은 무엇인가? 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는 게 가장 중요함. 이에 따라 콜백의 인터페이스를 정의해야하기 때문임. 제네릭스를 이용한 콜백 인터페이스\n파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶다면, 자바 언어에 타입 파라미터라는 개념을 도입한 제네릭스를 이용하면 됨. 3.6 스프링의 JdbcTemplate public class UserDao { public void setDataSource(DataSource dataSource) { this.jdbcTemplate = new JdbcTemplate(dataSource); } private JdbcTemplate jdbcTemplate; private RowMapper\u003cUser\u003e userMapper = new RowMapper\u003cUser\u003e() { public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setId(rs.getString(\"id\")); user.setName(rs.getString(\"name\")); user.setPassword(rs.getString(\"password\")); return user; } }; public void add(final User user) { this.jdbcTemplate.update(\"insert into users(id, name, password)values(?,?,?)\", user.getId(), user.getName(), user.getPassword()); } public User get(String id) { return this.jdbcTemplate.queryForObject(\"select * from users where id = ?\", new Object[] {id}, this.userMapper); } public void deleteAll() { this.jdbcTemplate.update(\"delete from users\"); } public int getCount() { return this.jdbcTemplate.queryForInt(\"select count(*) from users\"); } public List\u003cUser\u003e getAll() { return this.jdbcTemplate.query(\"select * from users order by id\", this.userMapper); } } 참고 자료 [book] 토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민 ","wordCount":"1063","inLanguage":"en","datePublished":"2022-12-18T00:13:50+09:00","dateModified":"2022-12-18T00:13:50+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/spring/spring_toby_3/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[토비의 스프링 3.1] 3장 정리</h1><div class=post-meta><span title='2022-12-18 00:13:50 +0900 KST'>December 18, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1063 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring/spring_toby_3.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#31-다시-보는-초난감-dao>3.1 다시 보는 초난감 DAO</a><ul><li><a href=#311-예외처리-기능을-갖춘-dao>3.1.1 예외처리 기능을 갖춘 DAO</a></li></ul></li><li><a href=#32-변하는-것과-변하지-않는-것>3.2 변하는 것과 변하지 않는 것</a><ul><li><a href=#321-jdbc-trycatchfinally-코드의-문제점>3.2.1 JDBC try/catch/finally 코드의 문제점</a></li><li><a href=#322-분리와-재사용을-위한-디자인-패턴-적용>3.2.2 분리와 재사용을 위한 디자인 패턴 적용</a></li></ul></li><li><a href=#33-jdbc-전략-패턴의-최적화>3.3 JDBC 전략 패턴의 최적화</a><ul><li><a href=#332-전략과-클라이언트의-동거>3.3.2 전략과 클라이언트의 동거</a></li></ul></li><li><a href=#34-컨텍스트와-di>3.4 컨텍스트와 DI</a><ul><li><a href=#342-jdbccontext의-특별한-di>3.4.2 JDBCContext의 특별한 DI</a></li></ul></li><li><a href=#35-템플릿과-콜백>3.5 템플릿과 콜백</a><ul><li><a href=#351-템플릿콜백의-동작원리>3.5.1 템플릿/콜백의 동작원리</a></li><li><a href=#353-템플릿콜백의-응용>3.5.3 템플릿/콜백의 응용</a></li></ul></li><li><a href=#36-스프링의-jdbctemplate>3.6 스프링의 JdbcTemplate</a></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><ul><li>개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것</li><li>템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법</li></ul><h2 id=31-다시-보는-초난감-dao>3.1 다시 보는 초난감 DAO<a hidden class=anchor aria-hidden=true href=#31-다시-보는-초난감-dao>#</a></h2><h3 id=311-예외처리-기능을-갖춘-dao>3.1.1 예외처리 기능을 갖춘 DAO<a hidden class=anchor aria-hidden=true href=#311-예외처리-기능을-갖춘-dao>#</a></h3><ul><li>DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함.)</li><li>일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리함.<ul><li>getConnection()으로 가져간 커넥션을 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있음.</li><li>Connection, PreparedStatement<ul><li>close() 메소드 - 만들어진 걸 종료하는 것이라고 볼 수 있지만 보통 리소스를 반환한다는 의미로 이해하는 것이 좋음.</li><li>풀 방식으로 운영됨. (미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할 때 할당, 반환하면 다시 풀에 넣는 방식임.)</li><li>요청이 매우 서버 환경에서는 풀 방식 선호.</li></ul></li></ul></li><li>JDBC 코드에서는 리소스를 반환하도록 try/catch/finally 구문 사용을 권장함.</li></ul><h2 id=32-변하는-것과-변하지-않는-것>3.2 변하는 것과 변하지 않는 것<a hidden class=anchor aria-hidden=true href=#32-변하는-것과-변하지-않는-것>#</a></h2><h3 id=321-jdbc-trycatchfinally-코드의-문제점>3.2.1 JDBC try/catch/finally 코드의 문제점<a hidden class=anchor aria-hidden=true href=#321-jdbc-trycatchfinally-코드의-문제점>#</a></h3><ul><li>코드가 복잡하고 중첩되어 있음.</li></ul><p>→ 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 분리</p><h3 id=322-분리와-재사용을-위한-디자인-패턴-적용>3.2.2 분리와 재사용을 위한 디자인 패턴 적용<a hidden class=anchor aria-hidden=true href=#322-분리와-재사용을-위한-디자인-패턴-적용>#</a></h3><p><strong>템플릿 메소드 패턴의 적용</strong></p><ul><li>상속을 통해 기능 확장해서 사용.</li><li>변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것임.</li><li>문제점<ul><li>DAO 로직마다 상속 통해 새로운 클래스 만들어야함.</li><li>확장구조가 클래스를 설계하는 시점에서 고정되어 버림.</li></ul></li></ul><p><strong>전략 패턴의 적용</strong></p><ul><li>개방폐쇄원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴임.</li></ul><p><strong>DI 적용을 위한 클라이언트/컨텍스트 분리</strong></p><ul><li>전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적임.</li><li>DI란 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조임.</li><li>마이크로 DI<ul><li>DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것임.</li><li>DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고 함.</li></ul></li></ul><h2 id=33-jdbc-전략-패턴의-최적화>3.3 JDBC 전략 패턴의 최적화<a hidden class=anchor aria-hidden=true href=#33-jdbc-전략-패턴의-최적화>#</a></h2><p>문제 상황</p><ul><li><ol><li>DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 함. → 클래스 파일의 수 증가</li></ol></li><li><ol start=2><li>DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 함.</li></ol></li></ul><h3 id=332-전략과-클라이언트의-동거>3.3.2 전략과 클라이언트의 동거<a hidden class=anchor aria-hidden=true href=#332-전략과-클라이언트의-동거>#</a></h3><p><strong>로컬 클래스</strong></p><ul><li><ol><li>해결법 - StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의하기.</li></ol></li><li>중첩 클래스(nested class)의 종류<ul><li>스태틱 클래스 - 독립적으로 오브젝트로 만들어질 수 있음.</li><li>내부 클래스 - 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음.<ul><li>범위에 따라 구분<ul><li>멤버 내부 클래스 - 멤버 필드처럼 오브젝트 레벨에 정의</li><li>로컬 클래스 - 메소드 레벨에 정의</li><li>익명 내부 클래스 - 이름을 갖지 않는 클래스. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용함.</li></ul></li></ul></li></ul></li></ul><h2 id=34-컨텍스트와-di>3.4 컨텍스트와 DI<a hidden class=anchor aria-hidden=true href=#34-컨텍스트와-di>#</a></h2><h3 id=342-jdbccontext의-특별한-di>3.4.2 JDBCContext의 특별한 DI<a hidden class=anchor aria-hidden=true href=#342-jdbccontext의-특별한-di>#</a></h3><p><strong>스프링 빈으로 DI</strong></p><ul><li>인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있지 않을까? 스프링 DI의 기본 의도에 맞게 JdbcContext의 메소드를 인터페이스를 뽑아내어 정의해두고, 이를 UserDao에서 사용해야 하지 않을까?<ul><li>꼭 인터페이스 사용안해도 됨.</li></ul></li><li>스프링의 DI는 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC 개념을 포괄함. → JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입했다는 건 DI 따른 것임.</li><li>JdbcContext를 UserDao와 DI 구조로 만들어야 할 이유<ul><li><ol><li>JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤빈이 되기 때문임.</li></ol></li><li><ol start=2><li>JdbcContext가 DI를 통해 다른 빈에 의존하고 있음.</li></ol><ul><li>DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 함.</li></ul></li></ul></li><li>클래스를 바로 사용하는 코드 구성을 DI에 적용하는 것은 가장 마지막 단계에서 고려해볼 사항임.</li><li>장점 - 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러남.</li><li>단점 - DI의 근본적인 원칙에 부합하지 않은 구체적인 클래스와의 관계가 설정에 직접 노출됨.</li></ul><p><strong>코드를 이용하는 수동 DI</strong></p><ul><li>장점 - JdbcContext가 UserDao의 내부에서 만들어지고 사용되면서 관계를 외부에는 드러내지 않아도 됨.</li><li>단점 - JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요함.</li></ul><h2 id=35-템플릿과-콜백>3.5 템플릿과 콜백<a hidden class=anchor aria-hidden=true href=#35-템플릿과-콜백>#</a></h2><ul><li>템플릿/콜백 패턴<ul><li>템플릿 - 전략 패턴의 컨텍스트<ul><li>템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이루어짐.</li></ul></li><li>콜백 - 익명 내부 클래스로 만들어지는 오브젝트<ul><li>실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말함.</li><li>파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용함.</li></ul></li></ul></li></ul><h3 id=351-템플릿콜백의-동작원리>3.5.1 템플릿/콜백의 동작원리<a hidden class=anchor aria-hidden=true href=#351-템플릿콜백의-동작원리>#</a></h3><p><strong>템플릿/콜백의 특징</strong></p><ul><li>템플릿/콜백의 작업 흐름<ul><li>[1] 클라이언트는 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트 생성. (콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달함.)</li><li>[2] 클라이언트는 콜백 전달 및 template 호출</li><li>[3] 템플릿 workflow 시작</li><li>[4] 템플릿은 참조 정보 생성</li><li>[5] 템플릿은 콜백 오브젝트의 메소드를 호출함.</li><li>[6] 콜백은 client final 변수를 참조</li><li>[7] 콜백은 참조정보를 이용해 작업 수행</li><li>[8] 콜백은 콜백 작업 결과를 템플릿에 돌려줌.</li><li>[9] 템플릿은 콜백이 돌려준 정보를 사용해 작업 마저 수행</li><li>[10] 템플릿은 경우에 따라 최종결과를 클라이언트에 돌려줌.</li></ul></li><li>템플릿/콜백 방식의 특징<ul><li>콜백은 단일 메소드 인터페이스를 사용함.</li><li>콜백 인터페이스의 메소드에는 보통 파라미터가 있음. 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용됨</li><li>템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받음.<ul><li>일반 DI라면 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용함.</li></ul></li><li>콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조.</li><li>클라이언트와 콜백이 강하게 결합됨.</li></ul></li><li>템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법임.</li></ul><h3 id=353-템플릿콜백의-응용>3.5.3 템플릿/콜백의 응용<a hidden class=anchor aria-hidden=true href=#353-템플릿콜백의-응용>#</a></h3><ul><li>스프링의 기본이 되는 전략 패턴과 DI는 물론이고 템플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다.</li><li>고정된 작업 흐름을 갖고 있으면서 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자.</li><li>가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드임.</li></ul><p><strong>중복의 제거와 템플릿/콜백 설계</strong></p><ul><li>템플릿에 담을 작업 흐름은 어떤 것인지 살펴보기.</li><li>템플릿이 콜백에게 전달해줄 내부의 정보는 무엇인가? 콜백이 템플릿에게 돌려줄 내용은 무엇인가?</li><li>템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는 게 가장 중요함. 이에 따라 콜백의 인터페이스를 정의해야하기 때문임.</li></ul><p><strong>제네릭스를 이용한 콜백 인터페이스</strong></p><ul><li>파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶다면, 자바 언어에 타입 파라미터라는 개념을 도입한 제네릭스를 이용하면 됨.</li></ul><h2 id=36-스프링의-jdbctemplate>3.6 스프링의 JdbcTemplate<a hidden class=anchor aria-hidden=true href=#36-스프링의-jdbctemplate>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserDao</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=kt>void</span> <span class=nf>setDataSource</span><span class=o>(</span><span class=n>DataSource</span> <span class=n>dataSource</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JdbcTemplate</span><span class=o>(</span><span class=n>dataSource</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		 
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	 <span class=kd>private</span> <span class=n>JdbcTemplate</span> <span class=n>jdbcTemplate</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>	 <span class=kd>private</span> <span class=n>RowMapper</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>userMapper</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>			 <span class=k>new</span> <span class=n>RowMapper</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=kd>public</span> <span class=n>User</span> <span class=nf>mapRow</span><span class=o>(</span><span class=n>ResultSet</span> <span class=n>rs</span><span class=o>,</span> <span class=kt>int</span> <span class=n>rowNum</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>SQLException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			 <span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=k>new</span> <span class=n>User</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			 <span class=n>user</span><span class=o>.</span><span class=na>setId</span><span class=o>(</span><span class=n>rs</span><span class=o>.</span><span class=na>getString</span><span class=o>(</span><span class=s>&#34;id&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>			 <span class=n>user</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=n>rs</span><span class=o>.</span><span class=na>getString</span><span class=o>(</span><span class=s>&#34;name&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>			 <span class=n>user</span><span class=o>.</span><span class=na>setPassword</span><span class=o>(</span><span class=n>rs</span><span class=o>.</span><span class=na>getString</span><span class=o>(</span><span class=s>&#34;password&#34;</span><span class=o>));</span>
</span></span><span class=line><span class=cl>			 <span class=k>return</span> <span class=n>user</span><span class=o>;</span>
</span></span><span class=line><span class=cl>		 <span class=o>}</span>
</span></span><span class=line><span class=cl>	 <span class=o>};</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>	 <span class=kd>public</span> <span class=kt>void</span> <span class=nf>add</span><span class=o>(</span><span class=kd>final</span> <span class=n>User</span> <span class=n>user</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span><span class=o>.</span><span class=na>update</span><span class=o>(</span><span class=s>&#34;insert into users(id, name, password)values(?,?,?)&#34;</span><span class=o>,</span> 
</span></span><span class=line><span class=cl>				 <span class=n>user</span><span class=o>.</span><span class=na>getId</span><span class=o>(),</span> <span class=n>user</span><span class=o>.</span><span class=na>getName</span><span class=o>(),</span> <span class=n>user</span><span class=o>.</span><span class=na>getPassword</span><span class=o>());</span>
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>	 <span class=kd>public</span> <span class=n>User</span> <span class=nf>get</span><span class=o>(</span><span class=n>String</span> <span class=n>id</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span><span class=o>.</span><span class=na>queryForObject</span><span class=o>(</span><span class=s>&#34;select * from users where id = ?&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>				 <span class=k>new</span> <span class=n>Object</span><span class=o>[]</span> <span class=o>{</span><span class=n>id</span><span class=o>},</span> <span class=k>this</span><span class=o>.</span><span class=na>userMapper</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>	 <span class=kd>public</span> <span class=kt>void</span> <span class=nf>deleteAll</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span><span class=o>.</span><span class=na>update</span><span class=o>(</span><span class=s>&#34;delete from users&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl>	 <span class=kd>public</span> <span class=kt>int</span> <span class=nf>getCount</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span><span class=o>.</span><span class=na>queryForInt</span><span class=o>(</span><span class=s>&#34;select count(*) from users&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	 <span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=nf>getAll</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		 <span class=k>return</span> <span class=k>this</span><span class=o>.</span><span class=na>jdbcTemplate</span><span class=o>.</span><span class=na>query</span><span class=o>(</span><span class=s>&#34;select * from users order by id&#34;</span><span class=o>,</span>
</span></span><span class=line><span class=cl>				 <span class=k>this</span><span class=o>.</span><span class=na>userMapper</span><span class=o>);</span>
</span></span><span class=line><span class=cl>	 <span class=o>}</span>
</span></span><span class=line><span class=cl>	 
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h1 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h1><ul><li><a href=https://product.kyobobook.co.kr/detail/S000000935358>[book] <strong>토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/spring/>Spring</a></li><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=next href=http://slow-wave.github.io/post/spring/spring_toby_2/><span class=title>Next »</span><br><span>[토비의 스프링 3.1] 2장 정리</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>