<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[토비의 스프링 3.1] 2장 정리 | slow-wave blog</title><meta name=keywords content="Spring,Backend,Java"><meta name=description content="Intro 스프링의 핵심 = 객체지향 & 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트
테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)
→ 단위 테스트(unit test)
자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/spring/spring_toby_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[토비의 스프링 3.1] 2장 정리"><meta property="og:description" content="Intro 스프링의 핵심 = 객체지향 & 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트
테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)
→ 단위 테스트(unit test)
자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/spring/spring_toby_2/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-11T03:37:39+09:00"><meta property="article:modified_time" content="2022-12-11T03:37:39+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[토비의 스프링 3.1] 2장 정리"><meta name=twitter:description content="Intro 스프링의 핵심 = 객체지향 & 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트
테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)
→ 단위 테스트(unit test)
자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[토비의 스프링 3.1] 2장 정리","item":"http://slow-wave.github.io/post/spring/spring_toby_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[토비의 스프링 3.1] 2장 정리","name":"[토비의 스프링 3.1] 2장 정리","description":"Intro 스프링의 핵심 = 객체지향 \u0026amp; 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트\n테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)\n→ 단위 테스트(unit test)\n자동수행 테스트 코드\n테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임.","keywords":["Spring","Backend","Java"],"articleBody":"Intro 스프링의 핵심 = 객체지향 \u0026 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트\n테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)\n→ 단위 테스트(unit test)\n자동수행 테스트 코드\n테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임. 실행 작업의 번거로움 main() 메소드 이용하는 것보다 편리하고 체계적인 방법 필요함. 2.2 UserDaoTest 개선 2.2.1 테스트 검증의 자동화 테스트 실패 테스트 에러 : 에러가 발생해서 실패 테스트 실패 : 에러가 발생하진 않지만 기대한 답이 아님 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로된 자동화된 테스트 만들어두는 것이 좋음. 2.2.2 테스트의 효율적인 수행과 결과 관리 실용적인 테스트를 위한 도구 - JUnit 프레임워크 JUnit 프레임워크 요구 조건 메소드가 public으로 선언되어야 함. 메소드에 @Test 추가 2.3 개발자를 위한 테스팅 프레임워크 JUnit 스프링 학습을 위해서는 최소한의 JUnit 테스트 작성 \u0026 실행 방법 알아야 함. 2.3.1 JUnit 테스트 실행 방법 IDE\n@Test가 들어있는 테스트 클래스 선택 → eclipse run 메뉴의 JUnit Test 선택 2.3.3 포괄적인 테스트 JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용함. @Test 붙어있고 public 접근자가 있으며 리턴 값이 void형이고 파라미터가 없다는 조건 지키면 됨. JUnit은 특정한 테스트 메소드의 실행 순서를 보장하지 않음. (테스트 결과가 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것임.) 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 것이 좋음. 2.3.4 테스트가 이끄는 개발 기능설계를 위한 테스트\n기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수 있음. 테스트 주도 개발(TDD, Test Driven Development)\n만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법 TDD의 기본 원칙 - 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다 TDD에서는 테스즈 작성하고 코드를 만드는 작업의 주기를 짧게하는 것을 권장함 2.3.5 테스트 코드 개선 Junit의 테스트 수행 방식\n테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾음. 테스트 클래스의 오브젝트를 하나 만든다. @Before 메소드 있으면 실행 @Test 메소드 하나 호출하고 테스트 결과 저장 @After 메소드 있으면 실행 나머지 테스트 메소드에 대해 2~5번 반복 모든 테스트의 결과를 종합해서 돌려줌 각 테스트 메소드 실행시마다 테스트 클래스의 오브젝트를 새로 만든다.\n왜일까? JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장해주기 위해서 매번 새로운 오브젝트를 만들게 함. 픽스처(fixture)\n테스트를 수행하는 데 필요한 정보나 오브젝트 2.4 스프링 테스트 적용 애플리케이션 생성 방식 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있음. 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 함. 애플리케이션 컨텍스트 처럼 생성에 많은 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트 생성함. JUnit은 @BeforeClass 스태틱 메소드를 지원함. 이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있음. 스프링이 제공하는 애플리케이션 컨텍스트 테스트 지원 기능이 더 편리함. 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공함. 스프링 테스트 컨텍스트 프레임워크 적용\n@Autowired @RunWith - 스프링의 테스트 컨텍스트 프레임워크의 Junit 확장기능 지정 @ContextConfiguration - 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정 테스트 메소드의 컨텍스트 공유\nJUnit은 테스트 메소드 실행시마다 새로운 테스트 오브젝트 생성 → context 변수에 어떻게 애플리케이션 컨텍스트가 들어있을까?\n→ 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것임.\n→ 스프링이 애플리케이션 컨텍스트 개수에 상관없이 한 번만 만들어서 공유해줬기 때문에 테스트 수행 속도 빨라짐.\n테스트 클래스의 컨텍스트 공유\n스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다. @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾음. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입. 별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져올 수 있음. → 타입에 의한 자동와이어링 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾음. 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋음. 2.4.2 DI와 테스트 인터페이스를 두고 DI를 적용해야 하는 이유 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있음. 효율적인 테스트를 만들기 위해서임. 테스트 코드에 의한 DI\n@DirtiesContext - 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌. DI를 이용한 테스트 방법 선택\n항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 최우선으로 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트 테스트 → 스프링의 설정을 이용한 DI 방식의 테스트\n2.5 학습 테스트로 배우는 스프링 학습 테스트(learning test) 학습테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용법 익히는 것. 2.5.1 학습 테스트의 장점 다양한 조건에 따른 기능을 손쉽게 확인 프레임워크나 제품을 업그레이드할 때 호환성 검증 도와줌. 테스트 작성에 대한 좋은 훈련 새로운 기술을 공부하는 과정이 즐거워짐 스프링 학습 테스트를 만들 때 참고할 수 있는 좋은 소스는 스프링 자신에 대한 테스트 코드임. 2.5.3 버그 테스트(bug test) 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트 버그테스트는 실패하도록 만들어야 함. 테스트 방법 동등분할 - 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트 경계값 분석 - 에러는 동등분할 범위의 경계에서 주로 발생. 경계의 근처에 있는 값을 이용해 테스트하는 방법임. 참고 자료 [book] 토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민 ","wordCount":"867","inLanguage":"en","datePublished":"2022-12-11T03:37:39+09:00","dateModified":"2022-12-11T03:37:39+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/spring/spring_toby_2/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[토비의 스프링 3.1] 2장 정리</h1><div class=post-meta><span title='2022-12-11 03:37:39 +0900 KST'>December 11, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;867 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/spring/spring_toby_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#21-userdaotest-다시-보기>2.1 UserDaoTest 다시 보기</a><ul><li><a href=#212-userdaotest의-특징>2.1.2 UserDaoTest의 특징</a></li><li><a href=#213-userdaotest의-문제점>2.1.3 UserDaoTest의 문제점</a></li></ul></li><li><a href=#22-userdaotest-개선>2.2 UserDaoTest 개선</a><ul><li><a href=#221-테스트-검증의-자동화>2.2.1 테스트 검증의 자동화</a></li><li><a href=#222-테스트의-효율적인-수행과-결과-관리>2.2.2 테스트의 효율적인 수행과 결과 관리</a></li></ul></li><li><a href=#23-개발자를-위한-테스팅-프레임워크-junit>2.3 개발자를 위한 테스팅 프레임워크 JUnit</a><ul><li><a href=#231-junit-테스트-실행-방법>2.3.1 JUnit 테스트 실행 방법</a></li><li><a href=#233-포괄적인-테스트>2.3.3 포괄적인 테스트</a></li><li><a href=#234-테스트가-이끄는-개발>2.3.4 테스트가 이끄는 개발</a></li><li><a href=#235-테스트-코드-개선>2.3.5 테스트 코드 개선</a></li></ul></li><li><a href=#24-스프링-테스트-적용>2.4 스프링 테스트 적용</a><ul><li><a href=#241-테스트를-위한-애플리케이션-컨텍스트-관리>2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리</a></li><li><a href=#242-di와-테스트>2.4.2 DI와 테스트</a></li></ul></li><li><a href=#25-학습-테스트로-배우는-스프링>2.5 학습 테스트로 배우는 스프링</a><ul><li><a href=#251-학습-테스트의-장점>2.5.1 학습 테스트의 장점</a></li><li><a href=#253-버그-테스트bug-test>2.5.3 버그 테스트(bug test)</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><ul><li>스프링의 핵심 = 객체지향 & 테스트</li><li>테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임.</li></ul><h2 id=21-userdaotest-다시-보기>2.1 UserDaoTest 다시 보기<a hidden class=anchor aria-hidden=true href=#21-userdaotest-다시-보기>#</a></h2><h3 id=212-userdaotest의-특징>2.1.2 UserDaoTest의 특징<a hidden class=anchor aria-hidden=true href=#212-userdaotest의-특징>#</a></h3><p><strong>작은 단위의 테스트</strong></p><ul><li>테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함.</li></ul><p>→ 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)</p><p>→ 단위 테스트(unit test)</p><p><strong>자동수행 테스트 코드</strong></p><ul><li>테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.)</li></ul><h3 id=213-userdaotest의-문제점>2.1.3 UserDaoTest의 문제점<a hidden class=anchor aria-hidden=true href=#213-userdaotest의-문제점>#</a></h3><ul><li>수동 확인 작업의 번거로움<ul><li>테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임.</li></ul></li><li>실행 작업의 번거로움<ul><li>main() 메소드 이용하는 것보다 편리하고 체계적인 방법 필요함.</li></ul></li></ul><h2 id=22-userdaotest-개선>2.2 UserDaoTest 개선<a hidden class=anchor aria-hidden=true href=#22-userdaotest-개선>#</a></h2><h3 id=221-테스트-검증의-자동화>2.2.1 테스트 검증의 자동화<a hidden class=anchor aria-hidden=true href=#221-테스트-검증의-자동화>#</a></h3><ul><li>테스트 실패<ul><li>테스트 에러 : 에러가 발생해서 실패</li><li>테스트 실패 : 에러가 발생하진 않지만 기대한 답이 아님</li></ul></li><li>빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로된 자동화된 테스트 만들어두는 것이 좋음.</li></ul><h3 id=222-테스트의-효율적인-수행과-결과-관리>2.2.2 테스트의 효율적인 수행과 결과 관리<a hidden class=anchor aria-hidden=true href=#222-테스트의-효율적인-수행과-결과-관리>#</a></h3><ul><li>실용적인 테스트를 위한 도구 - JUnit 프레임워크</li><li>JUnit 프레임워크 요구 조건<ul><li>메소드가 public으로 선언되어야 함.</li><li>메소드에 @Test 추가</li></ul></li></ul><h2 id=23-개발자를-위한-테스팅-프레임워크-junit>2.3 개발자를 위한 테스팅 프레임워크 JUnit<a hidden class=anchor aria-hidden=true href=#23-개발자를-위한-테스팅-프레임워크-junit>#</a></h2><ul><li>스프링 학습을 위해서는 최소한의 JUnit 테스트 작성 & 실행 방법 알아야 함.</li></ul><h3 id=231-junit-테스트-실행-방법>2.3.1 JUnit 테스트 실행 방법<a hidden class=anchor aria-hidden=true href=#231-junit-테스트-실행-방법>#</a></h3><p><strong>IDE</strong></p><ul><li>@Test가 들어있는 테스트 클래스 선택 → eclipse run 메뉴의 JUnit Test 선택</li></ul><h3 id=233-포괄적인-테스트>2.3.3 포괄적인 테스트<a hidden class=anchor aria-hidden=true href=#233-포괄적인-테스트>#</a></h3><ul><li>JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용함.<ul><li>@Test 붙어있고 public 접근자가 있으며 리턴 값이 void형이고 파라미터가 없다는 조건 지키면 됨.</li></ul></li><li>JUnit은 특정한 테스트 메소드의 실행 순서를 보장하지 않음. (테스트 결과가 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것임.)</li><li>테스트를 작성할 때 부정적인 케이스를 먼저 만드는 것이 좋음.</li></ul><h3 id=234-테스트가-이끄는-개발>2.3.4 테스트가 이끄는 개발<a hidden class=anchor aria-hidden=true href=#234-테스트가-이끄는-개발>#</a></h3><p><strong>기능설계를 위한 테스트</strong></p><ul><li>기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수 있음.</li></ul><p><strong>테스트 주도 개발(TDD, Test Driven Development)</strong></p><ul><li>만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법</li><li>TDD의 기본 원칙 - 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다</li><li>TDD에서는 테스즈 작성하고 코드를 만드는 작업의 주기를 짧게하는 것을 권장함</li></ul><h3 id=235-테스트-코드-개선>2.3.5 테스트 코드 개선<a hidden class=anchor aria-hidden=true href=#235-테스트-코드-개선>#</a></h3><p>Junit의 테스트 수행 방식</p><ul><li><ol><li>테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾음.</li></ol></li><li><ol start=2><li>테스트 클래스의 오브젝트를 하나 만든다.</li></ol></li><li><ol start=3><li>@Before 메소드 있으면 실행</li></ol></li><li><ol start=4><li>@Test 메소드 하나 호출하고 테스트 결과 저장</li></ol></li><li><ol start=5><li>@After 메소드 있으면 실행</li></ol></li><li><ol start=6><li>나머지 테스트 메소드에 대해 2~5번 반복</li></ol></li><li><ol start=7><li>모든 테스트의 결과를 종합해서 돌려줌</li></ol></li><li><p>각 테스트 메소드 실행시마다 테스트 클래스의 오브젝트를 새로 만든다.</p><ul><li>왜일까? JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장해주기 위해서 매번 새로운 오브젝트를 만들게 함.</li></ul></li></ul><p><strong>픽스처(fixture)</strong></p><ul><li>테스트를 수행하는 데 필요한 정보나 오브젝트</li></ul><h2 id=24-스프링-테스트-적용>2.4 스프링 테스트 적용<a hidden class=anchor aria-hidden=true href=#24-스프링-테스트-적용>#</a></h2><ul><li>애플리케이션 생성 방식<ul><li>빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있음.</li><li>애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 함.</li></ul></li><li>애플리케이션 컨텍스트 처럼 생성에 많은 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트 생성함.</li><li>JUnit은 @BeforeClass 스태틱 메소드를 지원함.<ul><li>이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있음.</li><li>스프링이 제공하는 애플리케이션 컨텍스트 테스트 지원 기능이 더 편리함.</li></ul></li></ul><h3 id=241-테스트를-위한-애플리케이션-컨텍스트-관리>2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리<a hidden class=anchor aria-hidden=true href=#241-테스트를-위한-애플리케이션-컨텍스트-관리>#</a></h3><ul><li>스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공함.</li></ul><p><strong>스프링 테스트 컨텍스트 프레임워크 적용</strong></p><ul><li>@Autowired</li><li>@RunWith - 스프링의 테스트 컨텍스트 프레임워크의 Junit 확장기능 지정</li><li>@ContextConfiguration - 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정</li></ul><p><strong>테스트 메소드의 컨텍스트 공유</strong></p><ul><li>JUnit은 테스트 메소드 실행시마다 새로운 테스트 오브젝트 생성</li></ul><p>→ context 변수에 어떻게 애플리케이션 컨텍스트가 들어있을까?</p><p>→ 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것임.</p><p>→ 스프링이 애플리케이션 컨텍스트 개수에 상관없이 한 번만 만들어서 공유해줬기 때문에 테스트 수행 속도 빨라짐.</p><p><strong>테스트 클래스의 컨텍스트 공유</strong></p><ul><li>스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.</li><li>@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾음.<ul><li>타입이 일치하는 빈이 있으면 인스턴스 변수에 주입.</li><li>별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져올 수 있음. → 타입에 의한 자동와이어링</li><li>변수에 할당 가능한 타입을 가진 빈을 자동으로 찾음.</li></ul></li><li>테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋음.</li></ul><h3 id=242-di와-테스트>2.4.2 DI와 테스트<a hidden class=anchor aria-hidden=true href=#242-di와-테스트>#</a></h3><ul><li>인터페이스를 두고 DI를 적용해야 하는 이유<ul><li><ol><li>소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.</li></ol></li><li><ol start=2><li>클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있음.</li></ol></li><li><ol start=3><li>효율적인 테스트를 만들기 위해서임.</li></ol></li></ul></li></ul><p><strong>테스트 코드에 의한 DI</strong></p><ul><li>@DirtiesContext - 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌.</li></ul><p><strong>DI를 이용한 테스트 방법 선택</strong></p><ul><li>항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 최우선으로</li><li>여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트 테스트</li></ul><p>→ 스프링의 설정을 이용한 DI 방식의 테스트</p><h2 id=25-학습-테스트로-배우는-스프링>2.5 학습 테스트로 배우는 스프링<a hidden class=anchor aria-hidden=true href=#25-학습-테스트로-배우는-스프링>#</a></h2><ul><li>학습 테스트(learning test)</li><li>학습테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용법 익히는 것.</li></ul><h3 id=251-학습-테스트의-장점>2.5.1 학습 테스트의 장점<a hidden class=anchor aria-hidden=true href=#251-학습-테스트의-장점>#</a></h3><ul><li>다양한 조건에 따른 기능을 손쉽게 확인</li><li>프레임워크나 제품을 업그레이드할 때 호환성 검증 도와줌.</li><li>테스트 작성에 대한 좋은 훈련</li><li>새로운 기술을 공부하는 과정이 즐거워짐<ul><li>스프링 학습 테스트를 만들 때 참고할 수 있는 좋은 소스는 스프링 자신에 대한 테스트 코드임.</li></ul></li></ul><h3 id=253-버그-테스트bug-test>2.5.3 버그 테스트(bug test)<a hidden class=anchor aria-hidden=true href=#253-버그-테스트bug-test>#</a></h3><ul><li>코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트</li><li>버그테스트는 실패하도록 만들어야 함.</li><li>테스트 방법<ul><li>동등분할 - 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트</li><li>경계값 분석 - 에러는 동등분할 범위의 경계에서 주로 발생. 경계의 근처에 있는 값을 이용해 테스트하는 방법임.</li></ul></li></ul><h1 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h1><ul><li><a href=https://product.kyobobook.co.kr/detail/S000000935358>[book] <strong>토비의 스프링 3.1 Vol 1: 스프링의 이해와 원리, 이일민</strong></a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/spring/>Spring</a></li><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/spring/spring_toby_3/><span class=title>« Prev</span><br><span>[토비의 스프링 3.1] 3장 정리</span></a>
<a class=next href=http://slow-wave.github.io/post/problem_solving/ps_dp_1/><span class=title>Next »</span><br><span>[백준] DP 1 - 2579번 계단 오르기</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>