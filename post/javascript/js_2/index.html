<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교 | slow-wave blog</title><meta name=keywords content="Javascript"><meta name=description content="1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/javascript/js_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교"><meta property="og:description" content="1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/javascript/js_2/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-09T21:05:18+09:00"><meta property="article:modified_time" content="2023-02-09T21:05:18+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교"><meta name=twitter:description content="1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교","item":"http://slow-wave.github.io/post/javascript/js_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교","name":"[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교","description":"1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임.","keywords":["Javascript"],"articleBody":"1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임.) 변수와 값 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름임. 값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과임. 원시 값은 변경불가능하다? → 원시 값 자체를 변경할 수 없음을 의미함. 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 → 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킴. 변수가 참조하던 메모리 공간의 주소가 바뀜. → 왜 메모리 공간의 주소가 바뀌는가? → 원시값의 불변성 때문임. 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경하는 방법이 없음. 자바스크립트의 문자열 원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 정해야함. 원시 타입별로 메모리 공간의 크기가 미리 정해져 있음. 문자열의 경우는 길이에 따라 메모리 공간의 크기가 결정됨. 유사 배열 객체 배열처럼 인덱스로 프로퍼티 접근 가능, length 프로퍼티를 갖는 객체임. 값에 의한 전달 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달됨. code let score = 80; let copy = score; console.log(score === copy); //true score와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값임. code ... //score값을 변경해도 copy 변수의 값에는 영향을 주지 않음. score = 100; console.log(score === copy); //false 엄격하게 표현하면 변수에는 값이 아니라 메모리 주소가 전달된다! (전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.) → 메모리 공간에 저장되어 있는 어떤 값을 식별할 수 있어야하므로 변수와 같은 식별자는 메모리 주소를 기억한다. (식별자는 메모리 주소에 붙인 이름이라고 할 수 있음.) 2) 객체 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있음. → 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음. 원시 값은 상대적으로 적은 메모리를 소비한다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값보다 비용이 많이 든다. 자바스크립트의 객체 관리 방식 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있음. 클래스 기반 객체지향 언어(자바, C++)는 사전에 정의된 클래스를 기반으로 객체(인스턴스)생성함. 자바스크립트는 클래스 없이 객체 생성 가능함. 자바스크립트가 클래스 기반 객체지향 언어보다 객체 생성과 프로퍼티 접근의 비용이 더 많이 듦. 해결법 → V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 히든 클래스 방식을 사용함. 참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체임. 원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근함. 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근함. 객체는 왜 변경 가능한 값으로 설계되어 있는가? 메모리 사용의 효율성과 성능을 위해서임. 객체의 취약점 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있음. 참조에 의한 전달 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨. → 참조에 의한 전달\ncode\nconst person = { name: \"Lee\", }; //얕은 복사 const copy = person; //copy를 통해 객체 변경 copy.name = \"slow\"; console.log(person); //{name: 'slow'} console.log(copy); //{name: 'slow'} person, copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다. → 두 개의 식별자가 하나의 객체를 공유함. → 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음. 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일함. → 자바스크립트에는 값에 의한 전달만 존재함.\n참고 자료 [book] 모던 자바스크립트 Deep Dive, 이웅모 ","wordCount":"562","inLanguage":"en","datePublished":"2023-02-09T21:05:18+09:00","dateModified":"2023-02-09T21:05:18+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/javascript/js_2/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교</h1><div class=post-meta><span title='2023-02-09 21:05:18 +0900 KST'>February 9, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;562 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/javascript/js_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#0-정리>0) 정리</a></li><li><a href=#1-원시-값>1) 원시 값</a><ul><li><a href=#자바스크립트의-문자열>자바스크립트의 문자열</a></li><li><a href=#값에-의한-전달>값에 의한 전달</a></li></ul></li><li><a href=#2-객체>2) 객체</a><ul><li><a href=#참조에-의한-전달>참조에 의한 전달</a></li></ul></li><li><a href=#참고-자료>참고 자료</a></li></ul></nav></div></details></div><div class=post-content><h1 id=1-원시-값과-객체의-비교>1. 원시 값과 객체의 비교<a hidden class=anchor aria-hidden=true href=#1-원시-값과-객체의-비교>#</a></h1><h2 id=0-정리>0) 정리<a hidden class=anchor aria-hidden=true href=#0-정리>#</a></h2><ul><li>자바스크립트의 데이터 타입<ul><li>원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol</li><li>객체 타입(object/reference type): 객체</li></ul></li><li>원시 타입 vs. 객체 타입<table><thead><tr><th></th><th>원시 타입</th><th>객체 타입</th></tr></thead><tbody><tr><td>변경가능한가?</td><td>immutable</td><td>mutable</td></tr><tr><td>변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가?</td><td>실제 값</td><td>참조 값</td></tr><tr><td>변수를 다른 변수에 할당할 때 전달 방법은?</td><td>값에 의한 전달</td><td>참조에 의한 전달</td></tr></tbody></table></li></ul><h2 id=1-원시-값>1) 원시 값<a hidden class=anchor aria-hidden=true href=#1-원시-값>#</a></h2><ul><li>원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임.)</li><li>변수와 값<ul><li>변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름임.</li><li>값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과임.</li><li>원시 값은 변경불가능하다? → 원시 값 자체를 변경할 수 없음을 의미함.</li></ul></li><li>원시 값을 할당한 변수에 새로운 원시 값을 재할당하면
→ <strong>새로운 메모리 공간</strong>을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킴. 변수가 참조하던 메모리 공간의 주소가 바뀜.
→ 왜 메모리 공간의 주소가 바뀌는가?
→ 원시값의 불변성 때문임.</li><li>불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경하는 방법이 없음.</li></ul><h3 id=자바스크립트의-문자열>자바스크립트의 문자열<a hidden class=anchor aria-hidden=true href=#자바스크립트의-문자열>#</a></h3><ul><li>원시 값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 정해야함. 원시 타입별로 메모리 공간의 크기가 미리 정해져 있음.</li><li>문자열의 경우는 길이에 따라 메모리 공간의 크기가 결정됨.</li><li>유사 배열 객체<ul><li>배열처럼 인덱스로 프로퍼티 접근 가능, length 프로퍼티를 갖는 객체임.</li></ul></li></ul><h3 id=값에-의한-전달>값에 의한 전달<a hidden class=anchor aria-hidden=true href=#값에-의한-전달>#</a></h3><ul><li>변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 <strong>변수의 원시 값이 복사되어 전달</strong>됨.</li><li>code<div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=kd>let</span> <span class=nx>score</span> <span class=o>=</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nx>copy</span> <span class=o>=</span> <span class=nx>score</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>score</span> <span class=o>===</span> <span class=nx>copy</span><span class=p>);</span> <span class=c1>//true
</span></span></span></code></pre></div><ul><li>score와 copy 변수의 값은 <strong>다른 메모리 공간에 저장된 별개의 값</strong>임.</li></ul></li><li>code<div class=highlight><pre tabindex=0 class=chroma><code class=language-jsx data-lang=jsx><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c1>//score값을 변경해도 copy 변수의 값에는 영향을 주지 않음.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>score</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>score</span> <span class=o>===</span> <span class=nx>copy</span><span class=p>);</span> <span class=c1>//false
</span></span></span></code></pre></div></li><li>엄격하게 표현하면 변수에는 값이 아니라 <strong>메모리 주소가 전달</strong>된다! (전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음.)
→ 메모리 공간에 저장되어 있는 어떤 값을 식별할 수 있어야하므로 변수와 같은 식별자는 <strong>메모리 주소</strong>를 기억한다. (식별자는 메모리 주소에 붙인 이름이라고 할 수 있음.)</li></ul><h2 id=2-객체>2) 객체<a hidden class=anchor aria-hidden=true href=#2-객체>#</a></h2><ul><li>객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있음.
→ 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음.</li><li>원시 값은 상대적으로 적은 메모리를 소비한다. 객체를 생성하고 프로퍼티에 접근하는 것도 원시 값보다 비용이 많이 든다.</li><li>자바스크립트의 객체 관리 방식<ul><li>자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있음.</li><li>클래스 기반 객체지향 언어(자바, C++)는 사전에 정의된 클래스를 기반으로 객체(인스턴스)생성함.</li><li>자바스크립트는 클래스 없이 객체 생성 가능함.</li><li>자바스크립트가 클래스 기반 객체지향 언어보다 객체 생성과 프로퍼티 접근의 비용이 더 많이 듦.<ul><li>해결법 → V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 히든 클래스 방식을 사용함.</li></ul></li></ul></li><li>참조값은 생성된 객체가 저장된 <strong>메모리 공간의 주소</strong>, 그 자체임.<ul><li>원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근함.</li><li>객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근함.</li></ul></li><li>객체는 왜 변경 가능한 값으로 설계되어 있는가?<ul><li>메모리 사용의 효율성과 성능을 위해서임.</li></ul></li><li>객체의 취약점<ul><li>원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있음.</li></ul></li></ul><h3 id=참조에-의한-전달>참조에 의한 전달<a hidden class=anchor aria-hidden=true href=#참조에-의한-전달>#</a></h3><ul><li><p>객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨.
→ 참조에 의한 전달</p></li><li><p>code</p><pre tabindex=0><code>const person = {
    name: &#34;Lee&#34;,
};
//얕은 복사
const copy = person;

//copy를 통해 객체 변경
copy.name = &#34;slow&#34;;

console.log(person); //{name: &#39;slow&#39;}
console.log(copy); //{name: &#39;slow&#39;}
</code></pre><ul><li>person, copy는 메모리 주소는 다르지만 동일한 참조 값을 갖는다.
→ 두 개의 식별자가 하나의 객체를 공유함.
→ 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음.</li></ul></li><li><p><strong>값에 의한 전달</strong>과 <strong>참조에 의한 전달</strong>은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일함. → 자바스크립트에는 <strong>값에 의한 전달</strong>만 존재함.</p></li></ul><h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><ul><li><a href=https://product.kyobobook.co.kr/detail/S000001766445>[book] 모던 자바스크립트 Deep Dive, 이웅모</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/javascript/>Javascript</a></li></ul><nav class=paginav><a class=next href=http://slow-wave.github.io/post/javascript/js_1/><span class=title>Next »</span><br><span>[javascript] 모던 자바스크립트 Deep Dive , 객체 리터럴</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>