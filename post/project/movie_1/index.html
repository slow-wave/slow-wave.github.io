<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[project] 토이 프로젝트 리팩토링 1 - REST API | slow-wave blog</title><meta name=keywords content="Backend,REST API"><meta name=description content="최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.
정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/project/movie_1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[project] 토이 프로젝트 리팩토링 1 - REST API"><meta property="og:description" content="최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.
정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/project/movie_1/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-20T18:03:37+09:00"><meta property="article:modified_time" content="2023-02-20T18:03:37+09:00"><meta property="og:site_name" content="slow-wave blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[project] 토이 프로젝트 리팩토링 1 - REST API"><meta name=twitter:description content="최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.
정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[project] 토이 프로젝트 리팩토링 1 - REST API","item":"http://slow-wave.github.io/post/project/movie_1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[project] 토이 프로젝트 리팩토링 1 - REST API","name":"[project] 토이 프로젝트 리팩토링 1 - REST API","description":"최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.\n정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다.","keywords":["Backend","REST API"],"articleBody":"최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.\n정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다. 요청을 보내는 주소만으로는 어떤 것을 요청 하는지 파악이 불가능하고 적절한 HTTP 상태 코드를 사용하지 않았습니다. 그래서 RESTful한 API로 수정하는 작업을 진행했습니다. 우선 REST API란 무엇인지 알아보겠습니다.\nREST API란? REST는 네트워크 아키텍처 원리의 모음입니다. ‘네트워크 아키텍처 원리’란 자원을 정의하고 자원에 대한 주소를 지정하는 방법을 의미합니다. 다시말하면 자원(resource)의 표현(representation)에 의한 상태 전달을 뜻합니다.\nREST API Quick Tips REST 스타일을 위해서는 다음의 내용을 고려해야합니다.\n첫번째, HTTP method를 지정해 무엇을 요청하는지 표현한다. HTTP method는 클라이언트가 웹서버에게 요청하는 목적 및 종류를 알리는 수단입니다. HTTP method의 종류에는 GET, POST, DELETE, PUT, PATCH, HEAD, OPTIONS 등이 있습니다.\nGET - 서버에게 Resource를 보내도록 요청 URL(URI) 형식으로 웹서버측 리소스(데이터)를 요청 POST - 클라이언트에서 서버로 Resource 제출 요청 데이터를 HTTP body에 담아서 전달 DELETE - 웹 리소스 제거 PUT - 웹 리소스 수정 PATCH - 웹 리소스의 일부분 수정 HEAD - 메세지 헤더 얻기 GET과 비슷하지만 실제 문서를 요청하는 것이 아니라 문서에 대한 정보를 요청 두번째, 적절한 리소스(URL 경로) 이름을 만든다. URL(URI) 이름을 보고 어떤 자원을 요청하는 것인지 알 수 있어야합니다. 리소스명을 정할 때 고민이 되어 IT회사에서 공개하는 REST API 명세서를 찾아본 적이 있습니다. MS의 경우 Microsoft’s internal company-wide REST API design guidelines을 제공합니다. 가이드라인을 살펴보면 URL 네이밍에 대한 규칙도 존재합니다.\n일반적인 리소스 이름에 대한 규칙은 다음과 같습니다.\nquery-string 대신에 identifiers를 사용함. Recommended: /users/12345 Not: /api?type=user\u0026id=12345 리소스 이름은 명사임. Recommended: /users/12345/getcomments Not:/users/12345/comments URL segments에는 복수형을 사용함. Recommended: /customers/33245/orders/8769 Not: /customer/33245/order/8769 URL segments에는 소문자를 사용함. 단어의 분리가 필요하면 underscores(‘_’) 나 hyphens(‘-’)를 사용함. URL은 가능한 짧게 하고 최대한 적은 세그먼트를 사용함. 세번째, HTTP Response Codes를 사용해 상태를 나타낸다. HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나입니다. 클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답을 보냅니다. 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려줍니다. HTTP 상태 코드에서 100번대는 정보 확인, 200번대는 통신 성공, 300번대는 리다이렉트, 400번대는 클라이언트 오류, 500번대는 서버 오류를 의미합니다.\n자주 사용하는 HTTP response code는 다음과 같습니다.\nHTTP response code 상태코드 이름 설명 200 OK 가장 흔하게 쓰이는 일반적인 성공 상태 코드임. 201 CREATED 요청 성공 \u0026 리소스가 새로 생성되었음을 의미함.(예 - POST, PUT) case - 회원가입을 통해 새로운 유저 정보가 생성됨. 204 NOT CONTENT 요청 성공 \u0026 요청과 관련되었던 컨텐츠가 없음을 의미함. (예 - DELETE, PUT case - 게시글 삭제 400 BAD REQUEST 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미함. 401 UNAUTHORIZED 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우 403 FORBIDDEN 사용자가 작업을 수행할 권한이 없거나 리소스를 사용할 수 없는 경우임. case - HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우 404 NOT FOUND 요청한 리소스가 존재하지 않을 경우임. 405 METHOD NOT ALLOWED 요청한 URL은 존재하지만 요청한 HTTP method가 적용되지 않음을 나타낼 때 사용함. 위의 내용을 참고해서 기존의 API를 변경하는 작업을 진행했습니다. 다음은 리뷰와 관련한 API입니다.\n수정 전 리뷰 상세 조회 /api/review/getOneReview 리뷰 등록 /api/review/submit 리뷰 수정 /api/review/edit 리뷰 삭제 /api/review/removeFromReview 수정 후 리뷰 상세 조회 GET /api/reviews/{reviewId} 리뷰 등록 POST /api/reviews 리뷰 수정 PATCH /api/reviews/{reviewId} 리뷰 삭제 DELETE /api/reviews/{reviewId} GraphQL GraphQL은 페이스북에서 만든 쿼리언어로 REST API를 대체할 수 있는 방법입니다. CSR(Client Side Rendering) 환경에서는 정교한 HTTP API 사용을 위해서 GraphQL을 사용합니다. gql은 웹 클라이언트가 데이터를 서버로 부터 효율적으로 가져오는 것이 목적입니다. 간단하게 REST API와 GraphQL를 비교하겠습니다. 둘 다 리소스를 URL로 식별하고 이를 통해 앱이 데이터나 기능을 가져올 수 있다는 공통점이 있습니다. 하지만 REST API의 경우 URL, METHOD등을 조합하기 때문에 다양한 Endpoint가 있는 반면 GraphQL은 단 하나의 endpoint가 있다는 차이점이 있습니다.\nREST API와 GraphQL은 SSR인지 CSR 환경인지에 따라서 결정되는 듯 보입니다. 다음에는 GraphQL과 REST API를 자세히 비교해보고 활용 사례를 알아보겠습니다.\n참고자료 [wiki] REST [blog] REST란? REST API 와 RESTful API의 차이점 [docs] REST API Quick Tips [blog] 서버의 상태를 알려주는 HTTP 상태 코드 [blog] GraphQL: API 소비자에 대한 일관된 접근방식 수립 [blog] GraphQL 개념잡기 ","wordCount":"685","inLanguage":"en","datePublished":"2023-02-20T18:03:37+09:00","dateModified":"2023-02-20T18:03:37+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/project/movie_1/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[project] 토이 프로젝트 리팩토링 1 - REST API</h1><div class=post-meta><span title='2023-02-20 18:03:37 +0900 KST'>February 20, 2023</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;685 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/project/movie_1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#rest-api란>REST API란?</a></li><li><a href=#rest-api-quick-tips>REST API Quick Tips</a><ul><li><a href=#첫번째-http-method를-지정해-무엇을-요청하는지-표현한다>첫번째, HTTP method를 지정해 무엇을 요청하는지 표현한다.</a></li><li><a href=#두번째-적절한-리소스url-경로-이름을-만든다>두번째, 적절한 리소스(URL 경로) 이름을 만든다.</a></li><li><a href=#세번째-http-response-codes를-사용해-상태를-나타낸다>세번째, HTTP Response Codes를 사용해 상태를 나타낸다.</a></li></ul></li><li><a href=#graphql>GraphQL</a></li><li><a href=#참고자료>참고자료</a></li></ul></nav></div></details></div><div class=post-content><p>최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.</p><p>정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다. 요청을 보내는 주소만으로는 어떤 것을 요청 하는지 파악이 불가능하고 적절한 HTTP 상태 코드를 사용하지 않았습니다. 그래서 RESTful한 API로 수정하는 작업을 진행했습니다. 우선 REST API란 무엇인지 알아보겠습니다.</p><h2 id=rest-api란>REST API란?<a hidden class=anchor aria-hidden=true href=#rest-api란>#</a></h2><p><strong>REST</strong>는 네트워크 아키텍처 원리의 모음입니다. &lsquo;네트워크 아키텍처 원리&rsquo;란 자원을 정의하고 자원에 대한 주소를 지정하는 방법을 의미합니다. 다시말하면 자원(resource)의 표현(representation)에 의한 상태 전달을 뜻합니다.</p><h2 id=rest-api-quick-tips>REST API Quick Tips<a hidden class=anchor aria-hidden=true href=#rest-api-quick-tips>#</a></h2><p>REST 스타일을 위해서는 다음의 내용을 고려해야합니다.</p><h3 id=첫번째-http-method를-지정해-무엇을-요청하는지-표현한다>첫번째, HTTP method를 지정해 무엇을 요청하는지 표현한다.<a hidden class=anchor aria-hidden=true href=#첫번째-http-method를-지정해-무엇을-요청하는지-표현한다>#</a></h3><p>HTTP method는 클라이언트가 웹서버에게 요청하는 목적 및 종류를 알리는 수단입니다. HTTP method의 종류에는 GET, POST, DELETE, PUT, PATCH, HEAD, OPTIONS 등이 있습니다.</p><ul><li>GET - 서버에게 Resource를 보내도록 요청<ul><li>URL(URI) 형식으로 웹서버측 리소스(데이터)를 요청</li></ul></li><li>POST - 클라이언트에서 서버로 Resource 제출<ul><li>요청 데이터를 HTTP body에 담아서 전달</li></ul></li><li>DELETE - 웹 리소스 제거</li><li>PUT - 웹 리소스 수정</li><li>PATCH - 웹 리소스의 일부분 수정</li><li>HEAD - 메세지 헤더 얻기<ul><li>GET과 비슷하지만 실제 문서를 요청하는 것이 아니라 문서에 대한 정보를 요청</li></ul></li></ul><h3 id=두번째-적절한-리소스url-경로-이름을-만든다>두번째, 적절한 리소스(URL 경로) 이름을 만든다.<a hidden class=anchor aria-hidden=true href=#두번째-적절한-리소스url-경로-이름을-만든다>#</a></h3><p>URL(URI) 이름을 보고 어떤 자원을 요청하는 것인지 알 수 있어야합니다. 리소스명을 정할 때 고민이 되어 IT회사에서 공개하는 REST API 명세서를 찾아본 적이 있습니다. MS의 경우 <a href=https://github.com/microsoft/api-guidelines>Microsoft&rsquo;s internal company-wide REST API design guidelines</a>을 제공합니다. 가이드라인을 살펴보면 URL 네이밍에 대한 규칙도 존재합니다.</p><p>일반적인 리소스 이름에 대한 규칙은 다음과 같습니다.</p><ul><li>query-string 대신에 identifiers를 사용함.<ul><li>Recommended: <code>/users/12345</code></li><li>Not: <code>/api?type=user&id=12345</code></li></ul></li><li>리소스 이름은 명사임.<ul><li>Recommended: <code>/users/12345/getcomments</code></li><li>Not:<code>/users/12345/comments</code></li></ul></li><li>URL segments에는 복수형을 사용함.<ul><li>Recommended: <code>/customers/33245/orders/8769</code></li><li>Not: <code>/customer/33245/order/8769</code></li></ul></li><li>URL segments에는 소문자를 사용함. 단어의 분리가 필요하면 underscores(‘_’) 나 hyphens(‘-’)를 사용함.</li><li>URL은 가능한 짧게 하고 최대한 적은 세그먼트를 사용함.</li></ul><h3 id=세번째-http-response-codes를-사용해-상태를-나타낸다>세번째, HTTP Response Codes를 사용해 상태를 나타낸다.<a hidden class=anchor aria-hidden=true href=#세번째-http-response-codes를-사용해-상태를-나타낸다>#</a></h3><p>HTTP 상태 코드는 클라이언트가 보냈던 요청의 수행 결과를 의미하는 일종의 약속이며, API를 구성하는 중요한 요소 중 하나입니다. 클라이언트가 서버에게 작업을 요청하면 서버는 요청받은 작업을 수행한 후 작업의 수행 결과를 응답을 보냅니다. 이때 HTTP 상태 코드를 사용하여 작업의 성공/실패 여부와 작업이 실패했다면 어떤 이유로 실패했는지도 알려줍니다. HTTP 상태 코드에서 100번대는 정보 확인, 200번대는 통신 성공, 300번대는 리다이렉트, 400번대는 클라이언트 오류, 500번대는 서버 오류를 의미합니다.</p><p>자주 사용하는 HTTP response code는 다음과 같습니다.</p><ul><li>HTTP response code<table><thead><tr><th>상태코드</th><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>가장 흔하게 쓰이는 일반적인 성공 상태 코드임.</td></tr><tr><td>201</td><td>CREATED</td><td>요청 성공 & 리소스가 새로 생성되었음을 의미함.(예 - POST, PUT) case - 회원가입을 통해 새로운 유저 정보가 생성됨.</td></tr><tr><td>204</td><td>NOT CONTENT</td><td>요청 성공 & 요청과 관련되었던 컨텐츠가 없음을 의미함. (예 - DELETE, PUT case - 게시글 삭제</td></tr><tr><td>400</td><td>BAD REQUEST</td><td>클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미함.</td></tr><tr><td>401</td><td>UNAUTHORIZED</td><td>인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우</td></tr><tr><td>403</td><td>FORBIDDEN</td><td>사용자가 작업을 수행할 권한이 없거나 리소스를 사용할 수 없는 경우임. case - HTTPS 프로토콜로만 접근해야하는 리소스에 HTTP 프로토콜을 사용하여 접근했을 경우</td></tr><tr><td>404</td><td>NOT FOUND</td><td>요청한 리소스가 존재하지 않을 경우임.</td></tr><tr><td>405</td><td>METHOD NOT ALLOWED</td><td>요청한 URL은 존재하지만 요청한 HTTP method가 적용되지 않음을 나타낼 때 사용함.</td></tr></tbody></table></li></ul><p>위의 내용을 참고해서 기존의 API를 변경하는 작업을 진행했습니다. 다음은 리뷰와 관련한 API입니다.</p><ul><li>수정 전<ul><li>리뷰 상세 조회 <code>/api/review/getOneReview</code></li><li>리뷰 등록 <code>/api/review/submit</code></li><li>리뷰 수정 <code>/api/review/edit</code></li><li>리뷰 삭제 <code>/api/review/removeFromReview</code></li></ul></li><li>수정 후<ul><li>리뷰 상세 조회 <code>GET /api/reviews/{reviewId}</code></li><li>리뷰 등록 <code>POST /api/reviews</code></li><li>리뷰 수정 <code>PATCH /api/reviews/{reviewId}</code></li><li>리뷰 삭제 <code>DELETE /api/reviews/{reviewId}</code></li></ul></li></ul><h2 id=graphql>GraphQL<a hidden class=anchor aria-hidden=true href=#graphql>#</a></h2><p>GraphQL은 페이스북에서 만든 쿼리언어로 REST API를 대체할 수 있는 방법입니다. CSR(Client Side Rendering) 환경에서는 정교한 HTTP API 사용을 위해서 GraphQL을 사용합니다. gql은 웹 클라이언트가 데이터를 서버로 부터 효율적으로 가져오는 것이 목적입니다. 간단하게 REST API와 GraphQL를 비교하겠습니다. 둘 다 리소스를 URL로 식별하고 이를 통해 앱이 데이터나 기능을 가져올 수 있다는 공통점이 있습니다. 하지만 REST API의 경우 URL, METHOD등을 조합하기 때문에 다양한 Endpoint가 있는 반면 GraphQL은 단 하나의 endpoint가 있다는 차이점이 있습니다.</p><p>REST API와 GraphQL은 SSR인지 CSR 환경인지에 따라서 결정되는 듯 보입니다. 다음에는 GraphQL과 REST API를 자세히 비교해보고 활용 사례를 알아보겠습니다.</p><h2 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h2><ul><li><a href=https://ko.wikipedia.org/wiki/REST>[wiki] REST</a></li><li><a href=https://dev-coco.tistory.com/97>[blog] REST란? REST API 와 RESTful API의 차이점</a></li><li><a href=https://www.restapitutorial.com/lessons/restquicktips.html>[docs] REST API Quick Tips</a></li><li><a href=https://evan-moon.github.io/2020/03/15/about-http-status-code/>[blog] 서버의 상태를 알려주는 HTTP 상태 코드</a></li><li><a href=https://cloud.google.com/blog/ko/products/api-management/interacting-with-apis-rest-and-graphql>[blog] GraphQL: API 소비자에 대한 일관된 접근방식 수립</a></li><li><a href=https://tech.kakao.com/2019/08/01/graphql-basic/>[blog] GraphQL 개념잡기</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/backend/>Backend</a></li><li><a href=http://slow-wave.github.io/tags/rest-api/>REST API</a></li></ul><nav class=paginav><a class=prev href=http://slow-wave.github.io/post/spring/spring_toby_8/><span class=title>« Prev</span><br><span>[토비의 스프링 3.1] 7장 정리</span></a>
<a class=next href=http://slow-wave.github.io/post/javascript/js_2/><span class=title>Next »</span><br><span>[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>