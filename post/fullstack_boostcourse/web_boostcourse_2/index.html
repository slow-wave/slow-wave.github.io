<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작 | slow-wave blog</title><meta name=keywords content="web,HTTP,boostcourse 웹프로그래밍 풀스택"><meta name=description content="Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 &ldquo;How Browsers Work: Behind the scenes of modern web browsers&ldquo;의 번역본을 정리한 것입니다.
1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.
2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다."><meta name=author content="Me"><link rel=canonical href=http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6F557TM67S"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6F557TM67S",{anonymize_ip:!1})}</script><meta property="og:title" content="[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작"><meta property="og:description" content="Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 &ldquo;How Browsers Work: Behind the scenes of modern web browsers&ldquo;의 번역본을 정리한 것입니다.
1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.
2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다."><meta property="og:type" content="article"><meta property="og:url" content="http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_2/"><meta property="og:image" content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-10-14T16:34:33+09:00"><meta property="article:modified_time" content="2022-10-14T16:34:33+09:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작"><meta name=twitter:description content="Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 &ldquo;How Browsers Work: Behind the scenes of modern web browsers&ldquo;의 번역본을 정리한 것입니다.
1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.
2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://slow-wave.github.io/post/"},{"@type":"ListItem","position":2,"name":"[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작","item":"http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작","name":"[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작","description":"Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 \u0026ldquo;How Browsers Work: Behind the scenes of modern web browsers\u0026ldquo;의 번역본을 정리한 것입니다.\n1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.\n2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다.","keywords":["web","HTTP","boostcourse 웹프로그래밍 풀스택"],"articleBody":" Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 “How Browsers Work: Behind the scenes of modern web browsers“의 번역본을 정리한 것입니다.\n1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.\n2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다. Browser Engine : UI와 Rendering Engine 사이의 동작을 제어합니다. Rendering Engine : 요청한 컨텐츠를 표시합니다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시합니다. Chrome의 경우 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지합니다. 각 탭은 독립된 프로세스로 처리됩니다. Networking : HTTP 요청과 같은 네트워크 호출에 사용됩니다. 이는 플랫폼 독립적인 UI이고 각 플랫폼 하부에서 실행됩니다. UI Backend : 콤보 박스와 창 같은 기본적인 장치를 그립니다. 플랫폼에서 명시하지 않은 일반적은 인터페이스로서, OS UI 체계를 사용합니다. Javascript Interpreter : javascript 코드를 해석하고 실행합니다. Data Persistence : 자료를 저장하는 계층입니다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드디스크에 저장해야합니다. HTML5 명세에는 브라우저가 지원하는 ‘웹 데이터 베이스’가 정의되어있습니다. 2. Rendering Engine 렌더링 엔진은 요청 받은 내용을 브라우저 화면에 표시하는 역할을 합니다.\nfirefox는 Gecko engine chrome, safari는 webkit engine을 사용함. 1) Rendering Engine 동작 과정 렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송됩니다.\n렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작합니다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것입니다.\n[1] HTML 파싱\n렌더링 엔진은 HTML 문서를 파싱하고 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환 [2] 렌더 트리 구축\n그 다음 외부 CSS파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더 트리라고 부르는 다른 트리를 생성 [3] 렌더 트리 배치\n배치란 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한 [4] 렌더 트리 그리기\nUI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정 3. Parsing - general 문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미합니다. 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 합니다.\n1) 문법 파싱은 문서에 작성된 언어 또는 형식의 규칙에 따르는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야합니다. 이것을 context free grammar라고 합니다. context free grammar라면 언어는 정규 파서로 파싱할 수 있습니다.\n2) Parser - Lexer combination(파서-어휘 분석기 조합) 파싱은 어휘 분석과 구문 분석 두가지로 구분할 수 있습니다.\n[1] 어휘 분석 : 자료를 토큰으로 분해하는 과정\n공백과 같은 의미없는 문자 제거 [2] 구문 분석 : 언어의 구문 규칙을 적용하는 과정\n언어 구문 규칙에 따라 문서 구조 분석 파싱 과정은 반복됩니다. 파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인합니다.\n규칙에 맞으면 토큰에 해당하는 노드가 파싱 트리에 추가 \u0026 파서는 다른 토큰 요청 규칙에 맞지 않으면 토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까지 요청 맞는 규칙이 없는 경우 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 것임 3) 변환 파서 트리는 최종 결과물이 아닙니다. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 됩니다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환합니다.\n4) parser의 종류 하향식 파서 : 구문의 상위 구조로부터 일치하는 부분을 찾음. 일치하는 다른 규칙을 점진적으로 찾아내면서 표현식을 찾음. 상향식 파서 : 낮은 수준에서 점차 높은 수준으로 찾음. 입력 값이 규칙에 맞을 때까지 찾아서 맞는 입력값을 규칙으로 바꾸는데 이 과정은 입력값의 끝까지 진행됨. 부분적으로 일치하는 표현식은 파서 스택에 쌓임. 5) 파서 자동 생성 파서를 생성해 줄 수 있는 도구를 파서 생성기라고 합니다. 언어에 구문 규칙 같은 문법을 부여하면 동작하는 파서를 만들어줍니다.\n4. HTML parser HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 context free grammar가 아닙니다.\n1) HTML DTD HTML의 정의는 DTD 형식 안에 있는데 SGML 계열 언어의 정의를 이용한 것입니다.\n2) DOM(Document Object Model) 파싱 트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 됩니다. 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점입니다. 트리의 최상위 객체는 문서입니다.\nDOM은 마크업과 1:1 관계를 갖습니다. HTML과 마찬가지로 DOM은 W3C에 의해 명세(www.w3.org/DOM/DOMTR )가 정해져 있습니다. \u003chtml\u003e \u003cbody\u003e \u003cp\u003eHello World\u003c/p\u003e \u003cdiv\u003e\u003cimg src=\"example.png\" /\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 5. Render tree construction DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축합니다. 표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적입니다.\nfirefox - frames webkit - renderer or render object renderer는 자신과 자식 요소를 어떻게 배치하고 그려내야 하는지 알고 있습니다.\n1) DOM tree와 Render tree의 관계 렌더러는 DOM 요소에 부합하지만 1:1로 대응하는 관계는 아닙니다. 예를 들어 head 요소와 같은 비시각적 DOM 요소는 렌더 트리에 추가되지 않습니다. 또한 display:none인 요소도 나타나지 않습니다.\n참고 자료 [1] [naver D2] 브라우저는 어떻게 동작하는가?\n[2] [web.dev] How browsers work\n","wordCount":"770","inLanguage":"en","datePublished":"2022-10-14T16:34:33+09:00","dateModified":"2022-10-14T16:34:33+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_2/"},"publisher":{"@type":"Organization","name":"slow-wave blog","logo":{"@type":"ImageObject","url":"http://slow-wave.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://slow-wave.github.io/ accesskey=h title="Home (Alt + H)"><img src=http://slow-wave.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://slow-wave.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=http://slow-wave.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=http://slow-wave.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://slow-wave.github.io/>Home</a>&nbsp;»&nbsp;<a href=http://slow-wave.github.io/post/>Posts</a></div><h1 class=post-title>[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작</h1><div class=post-meta><span title='2022-10-14 16:34:33 +0900 KST'>October 14, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;770 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/post/fullstack_boostcourse/web_boostcourse_2.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-broswer>1. broswer</a><ul><li><a href=#1-broswer의-주요-기능>1) broswer의 주요 기능</a></li><li><a href=#2-browser의-기본-구조>2) browser의 기본 구조</a></li></ul></li><li><a href=#2-rendering-engine>2. Rendering Engine</a><ul><li><a href=#1-rendering-engine-동작-과정>1) Rendering Engine 동작 과정</a></li></ul></li><li><a href=#3-parsing---general>3. <strong>Parsing - general</strong></a><ul><li><a href=#1-문법>1) 문법</a></li><li><a href=#2-parser---lexer-combination파서-어휘-분석기-조합>2) <strong>Parser - Lexer combination(파서-어휘 분석기 조합)</strong></a></li><li><a href=#3-변환>3) 변환</a></li><li><a href=#4-parser의-종류>4) parser의 종류</a></li><li><a href=#5-파서-자동-생성>5) 파서 자동 생성</a></li></ul></li><li><a href=#4-html-parser>4. HTML parser</a><ul><li><a href=#1-html-dtd>1) HTML DTD</a></li><li><a href=#2-domdocument-object-model>2) DOM(Document Object Model)</a></li></ul></li><li><a href=#5-render-tree-construction>5. <strong>Render tree construction</strong></a><ul><li><a href=#1-dom-tree와-render-tree의-관계>1) DOM tree와 Render tree의 관계</a></li></ul></li><li><a href=#참고-자료>참고 자료</a></li></ul></nav></div></details></div><div class=post-content><ol><li>Web개발의 이해</li></ol><ul><li><a href=https://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/>1-1. HTTP 프로토콜의 이해</a></li><li><a href=https://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_2/>1-2. browser의 동작</a></li><li>1-3. 웹서버</li><li>1-4. WAS</li></ul><p>이 글은 &ldquo;<a href=http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/>How Browsers Work: Behind the scenes of modern web browsers</a>&ldquo;의 번역본을 정리한 것입니다.</p><h2 id=1-broswer>1. broswer<a hidden class=anchor aria-hidden=true href=#1-broswer>#</a></h2><h3 id=1-broswer의-주요-기능>1) broswer의 주요 기능<a hidden class=anchor aria-hidden=true href=#1-broswer의-주요-기능>#</a></h3><p>브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.</p><h3 id=2-browser의-기본-구조>2) browser의 기본 구조<a hidden class=anchor aria-hidden=true href=#2-browser의-기본-구조>#</a></h3><figure><img loading=lazy src=/images/fullstack_boostcourse/web_boostcourse_2/0.png></figure><ul><li>UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다.</li><li>Browser Engine : UI와 Rendering Engine 사이의 동작을 제어합니다.</li><li>Rendering Engine : 요청한 컨텐츠를 표시합니다. HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시합니다.<ul><li>Chrome의 경우 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지합니다. 각 탭은 독립된 프로세스로 처리됩니다.</li></ul></li><li>Networking : HTTP 요청과 같은 네트워크 호출에 사용됩니다. 이는 플랫폼 독립적인 UI이고 각 플랫폼 하부에서 실행됩니다.</li><li>UI Backend : 콤보 박스와 창 같은 기본적인 장치를 그립니다. 플랫폼에서 명시하지 않은 일반적은 인터페이스로서, OS UI 체계를 사용합니다.</li><li>Javascript Interpreter : javascript 코드를 해석하고 실행합니다.</li><li>Data Persistence : 자료를 저장하는 계층입니다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드디스크에 저장해야합니다. HTML5 명세에는 브라우저가 지원하는 ‘웹 데이터 베이스&rsquo;가 정의되어있습니다.</li></ul><h2 id=2-rendering-engine>2. Rendering Engine<a hidden class=anchor aria-hidden=true href=#2-rendering-engine>#</a></h2><p>렌더링 엔진은 요청 받은 내용을 브라우저 화면에 표시하는 역할을 합니다.</p><ul><li>firefox는 Gecko engine</li><li>chrome, safari는 webkit engine을 사용함.</li></ul><h3 id=1-rendering-engine-동작-과정>1) Rendering Engine 동작 과정<a hidden class=anchor aria-hidden=true href=#1-rendering-engine-동작-과정>#</a></h3><p>렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송됩니다.</p><p>렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작합니다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것입니다.</p><figure><img loading=lazy src=/images/fullstack_boostcourse/web_boostcourse_2/1.png></figure><p>[1] HTML 파싱</p><ul><li>렌더링 엔진은 HTML 문서를 파싱하고 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환</li></ul><p>[2] 렌더 트리 구축</p><ul><li>그 다음 외부 CSS파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더 트리라고 부르는 다른 트리를 생성</li></ul><p>[3] 렌더 트리 배치</p><ul><li>배치란 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한</li></ul><p>[4] 렌더 트리 그리기</p><ul><li>UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정</li></ul><h2 id=3-parsing---general>3. <strong>Parsing - general</strong><a hidden class=anchor aria-hidden=true href=#3-parsing---general>#</a></h2><p>문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미합니다. 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 합니다.</p><h3 id=1-문법>1) 문법<a hidden class=anchor aria-hidden=true href=#1-문법>#</a></h3><p>파싱은 문서에 작성된 언어 또는 형식의 규칙에 따르는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야합니다. 이것을 <a href=https://web.dev/howbrowserswork/#context_free_grammar>context free grammar</a>라고 합니다. context free grammar라면 언어는 정규 파서로 파싱할 수 있습니다.</p><h3 id=2-parser---lexer-combination파서-어휘-분석기-조합>2) <strong>Parser - Lexer combination(파서-어휘 분석기 조합)</strong><a hidden class=anchor aria-hidden=true href=#2-parser---lexer-combination파서-어휘-분석기-조합>#</a></h3><p>파싱은 어휘 분석과 구문 분석 두가지로 구분할 수 있습니다.</p><p>[1] 어휘 분석 : 자료를 토큰으로 분해하는 과정</p><ul><li>공백과 같은 의미없는 문자 제거</li></ul><p>[2] 구문 분석 : 언어의 구문 규칙을 적용하는 과정</p><ul><li>언어 구문 규칙에 따라 문서 구조 분석</li></ul><figure><img loading=lazy src=/images/fullstack_boostcourse/web_boostcourse_2/2.png></figure><p>파싱 과정은 반복됩니다.
파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인합니다.</p><ul><li>규칙에 맞으면<ul><li>토큰에 해당하는 노드가 파싱 트리에 추가 & 파서는 다른 토큰 요청</li></ul></li><li>규칙에 맞지 않으면<ul><li>토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까지 요청</li><li>맞는 규칙이 없는 경우 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 것임</li></ul></li></ul><h3 id=3-변환>3) 변환<a hidden class=anchor aria-hidden=true href=#3-변환>#</a></h3><p>파서 트리는 최종 결과물이 아닙니다. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 됩니다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환합니다.</p><figure><img loading=lazy src=/images/fullstack_boostcourse/web_boostcourse_2/3.png></figure><h3 id=4-parser의-종류>4) parser의 종류<a hidden class=anchor aria-hidden=true href=#4-parser의-종류>#</a></h3><ul><li>하향식 파서 : 구문의 상위 구조로부터 일치하는 부분을 찾음.<ul><li>일치하는 다른 규칙을 점진적으로 찾아내면서 표현식을 찾음.</li></ul></li><li>상향식 파서 : 낮은 수준에서 점차 높은 수준으로 찾음.<ul><li>입력 값이 규칙에 맞을 때까지 찾아서 맞는 입력값을 규칙으로 바꾸는데 이 과정은 입력값의 끝까지 진행됨. 부분적으로 일치하는 표현식은 파서 스택에 쌓임.</li></ul></li></ul><h3 id=5-파서-자동-생성>5) 파서 자동 생성<a hidden class=anchor aria-hidden=true href=#5-파서-자동-생성>#</a></h3><p>파서를 생성해 줄 수 있는 도구를 파서 생성기라고 합니다. 언어에 구문 규칙 같은 문법을 부여하면 동작하는 파서를 만들어줍니다.</p><h2 id=4-html-parser>4. HTML parser<a hidden class=anchor aria-hidden=true href=#4-html-parser>#</a></h2><p>HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 context free grammar가 아닙니다.</p><h3 id=1-html-dtd>1) HTML DTD<a hidden class=anchor aria-hidden=true href=#1-html-dtd>#</a></h3><p>HTML의 정의는 DTD 형식 안에 있는데 SGML 계열 언어의 정의를 이용한 것입니다.</p><h3 id=2-domdocument-object-model>2) DOM(Document Object Model)<a hidden class=anchor aria-hidden=true href=#2-domdocument-object-model>#</a></h3><p>파싱 트리는 DOM 요소와 속성 노드의 트리로서 출력 트리가 됩니다. 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점입니다. 트리의 최상위 객체는 문서입니다.</p><ul><li>DOM은 마크업과 1:1 관계를 갖습니다.<ul><li>HTML과 마찬가지로 DOM은 W3C에 의해 명세(<a href=http://www.w3.org/DOM/DOMTR>www.w3.org/DOM/DOMTR</a>
)가 정해져 있습니다.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>Hello World<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=p>&lt;</span><span class=nt>div</span><span class=p>&gt;&lt;</span><span class=nt>img</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;example.png&#34;</span> <span class=p>/&gt;&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></div><figure><img loading=lazy src=/images/fullstack_boostcourse/web_boostcourse_2/4.png></figure><h2 id=5-render-tree-construction>5. <strong>Render tree construction</strong><a hidden class=anchor aria-hidden=true href=#5-render-tree-construction>#</a></h2><p>DOM 트리가 구축되는 동안 브라우저는 렌더 트리를 구축합니다. 표시해야 할 순서와 문서의 시각적인 구성 요소로써 올바른 순서로 내용을 그려낼 수 있도록 하기 위한 목적입니다.</p><ul><li>firefox - frames</li><li>webkit - renderer or render object</li></ul><p>renderer는 자신과 자식 요소를 어떻게 배치하고 그려내야 하는지 알고 있습니다.</p><h3 id=1-dom-tree와-render-tree의-관계>1) DOM tree와 Render tree의 관계<a hidden class=anchor aria-hidden=true href=#1-dom-tree와-render-tree의-관계>#</a></h3><p>렌더러는 DOM 요소에 부합하지만 1:1로 대응하는 관계는 아닙니다. 예를 들어 head 요소와 같은 비시각적 DOM 요소는 렌더 트리에 추가되지 않습니다. 또한 display:none인 요소도 나타나지 않습니다.</p><h2 id=참고-자료>참고 자료<a hidden class=anchor aria-hidden=true href=#참고-자료>#</a></h2><p>[1] <a href=https://d2.naver.com/helloworld/59361>[naver D2] 브라우저는 어떻게 동작하는가?</a><br>[2] <a href=https://web.dev/howbrowserswork/>[web.dev] How browsers work</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=http://slow-wave.github.io/tags/web/>web</a></li><li><a href=http://slow-wave.github.io/tags/http/>HTTP</a></li><li><a href=http://slow-wave.github.io/tags/boostcourse-%EC%9B%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%92%80%EC%8A%A4%ED%83%9D/>boostcourse 웹프로그래밍 풀스택</a></li></ul><nav class=paginav><a class=next href=http://slow-wave.github.io/post/algorithm/mst_1/><span class=title>Next »</span><br><span>[algorithm] MST(Minimum Spanning Tree)</span></a></nav></footer><script src=https://utteranc.es/client.js repo=slow-wave/blog_comments issue-term=pathname theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=http://slow-wave.github.io/>slow-wave blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>