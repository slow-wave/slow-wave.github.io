<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on slow-wave blog</title>
    <link>http://slow-wave.github.io/post/</link>
    <description>Recent content in Posts on slow-wave blog</description>
    <image>
      <url>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Apr 2023 03:29:48 +0900</lastBuildDate><atom:link href="http://slow-wave.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[토비의 스프링 3.1] 8장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_9/</link>
      <pubDate>Sun, 02 Apr 2023 03:29:48 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_9/</guid>
      <description>스프링이란 무엇인가? 스프링 프레임워크가 만들어진 이유와 존재 목적, 추구하는 가치는 무엇일까? 스프링의 정의 스프링 : 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 애플리케이션 프레임워크 : 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크임. 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는데 일차적인 목표를 두는 프레임워크임. 스프링의 탄생 스프링의 기원은 로드 존슨 책의 예제 코드임. 책에서 강조한 중요한 전략의 하나는 ‘항상 프레임워크로 접근하라’라는 것임.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 7장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_8/</link>
      <pubDate>Sun, 05 Mar 2023 03:12:21 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_8/</guid>
      <description>스프링의 3대 핵심 기술인 IoC/DI, 서비스 추상화, AOP를 애플리케이션 개발에 활용해보자. SQL과 DAO의 분리 SQL을 적절히 분리해 DAO 코드와 다른 파일이나 위치에 두고 관리하자 분리 방법 XML 설정을 이용한 분리 - SQL을 스프링의 XML 설정파일로 빼기 SQL 맵 프로퍼티 방식 - SQL을 하나의 컬렉션으로 담아두기. 맵의 키 값을 이용해 SQL 문장을 가져오게함. 스프링의 설정파일 안에 SQL을 두면 SQL과 DI 설정정보가 섞여 관리하기 어렵다는 문제가 있음. 해결) 독립적인 SQL 제공 서비스가 필요함.</description>
    </item>
    
    <item>
      <title>[project] 토이 프로젝트 리팩토링 1 - REST API</title>
      <link>http://slow-wave.github.io/post/project/movie_1/</link>
      <pubDate>Mon, 20 Feb 2023 18:03:37 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/project/movie_1/</guid>
      <description>최근에 영화 리뷰를 저장할 수 있는 웹 서비스를 개발하는 토이 프로젝트를 진행했습니다. MERN(MongoDB, Express, React, Node) 스택으로 개발했으며 TMDB API의 영화 정보를 활용했습니다. 왓챠피디아 같은 커뮤니티형보다는 개인 기록형 영화 리뷰 저장소를 만드는 것을 목표로 했습니다. 그래서 주 기능은 1) 영화를 탐색하고 2) 북마크하고 3) 리뷰를 작성하는 것입니다.
정의한 요구사항 대로 구현하니 기능은 잘 동작하지만 코드 상에는 많은 문제와 개선해야 할 점이 있다는 것을 알게되었습니다. 점차적으로 개선하면서 공부한 것들을 기록하려고 합니다. 제가 생각하는 가장 큰 문제는 잘못 설계된 HTTP API입니다.</description>
    </item>
    
    <item>
      <title>[javascript] 모던 자바스크립트 Deep Dive , 원시 값과 객체의 비교</title>
      <link>http://slow-wave.github.io/post/javascript/js_2/</link>
      <pubDate>Thu, 09 Feb 2023 21:05:18 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/javascript/js_2/</guid>
      <description>1. 원시 값과 객체의 비교 0) 정리 자바스크립트의 데이터 타입 원시 타입(primitive type): 숫자, 문자열, 불리언, null, undefined, symbol 객체 타입(object/reference type): 객체 원시 타입 vs. 객체 타입 원시 타입 객체 타입 변경가능한가? immutable mutable 변수에 할당시 확보된 메모리 공간에는 어떤 값이 저장되는가? 실제 값 참조 값 변수를 다른 변수에 할당할 때 전달 방법은? 값에 의한 전달 참조에 의한 전달 1) 원시 값 원시 타입의 값은 변경 불가능한 값이다. (한번 생성된 원시 값은 읽기 전용 값임.</description>
    </item>
    
    <item>
      <title>[javascript] 모던 자바스크립트 Deep Dive , 객체 리터럴</title>
      <link>http://slow-wave.github.io/post/javascript/js_1/</link>
      <pubDate>Tue, 07 Feb 2023 14:46:04 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/javascript/js_1/</guid>
      <description>10장 객체 리터럴 1) 객체란? 자바스크립트는 객체(object) 기반의 프로그래밍 언어다. 원시값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)은 모두 객체다. 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다. 객체 타입의 값은 mutable value다. (변할 수 있는 값) 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 key-value로 구성된다. 객체는 프로퍼티와 메서드로 구성된 집합체다. 프로퍼티 : 객체의 상태를 나타내는 값 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작 객체지향프로그래밍 : 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임 2) 객체 리터럴에 의한 객체 생성 자바스크립트는 프로토타입 기반 객체지향 언어로서 다양한 객체 생성 방법을 지원함.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 6장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_7/</link>
      <pubDate>Sun, 05 Feb 2023 04:56:34 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_7/</guid>
      <description>Intro AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술임. 단위 테스트 작은 단위의 테스트가 더 좋음. → 테스트 실패시 원인을 찾기가 쉬움. 테스트 단위가 작아야 테스트의 의도나 내용이 분명해짐. 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음. → 테스트 대역 사용 통합테스트 - 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트 단위테스트 vs.</description>
    </item>
    
    <item>
      <title>[javascript] ES6&#43; 핵심 문법 정리</title>
      <link>http://slow-wave.github.io/post/javascript/js_0/</link>
      <pubDate>Tue, 31 Jan 2023 16:31:43 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/javascript/js_0/</guid>
      <description>0) Intro javascript 문법 공부를 위해 Inflearn에 있는 강의를 듣고 정리한 글입니다. 두 강의 모두 자바스크립트 문법을 공부하는데 많은 도움이 되어 추천하고 싶습니다. 코드 예제의 경우 공부를 위해서 변형한 부분이 있습니다.
이룸코딩님의 자바스크립트 ES6+ 기초 핵심 문법 코딩앙마님의 자바스크립트 중급 강좌 1) 블록 범위 생성자 스코프 스코프는 변수에 접근 가능한 범위임. 종류 함수 레벨 스코프: 함수 블록 내에서 선언된 변수는 함수 내에서만 접근 가능 기존의 변수 선언 키워드인 var는 함수 스코프 블록 레벨 스코프:함수를 포함한 모든 코드 블록(함수, if 문, for문, while문, try/catch 문등) 내에서 선언된 변수는 코드 블록 내에서만 접근 가능 let, const는 블록 스코프 var의 문제점 함수를 제외한 다른 코드 블록에서는 개별적인 스코프를 가질 수 없다는 문제점 있음.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 5장 정리 - 2</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_6/</link>
      <pubDate>Sun, 29 Jan 2023 01:50:17 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_6/</guid>
      <description>5.2 트랜잭션 서비스 추상화 트랜잭션 경계설정 트랜잭션 : 더 이상 나눌 수 없는 단위 작업임. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성임. 중간에 예외가 발생해서 작업을 완료할 수 없다면 작업이 시작되지 않은 초기 상태로 되돌려놔야함. 하나의 SQL을 처리하는 경우 DB가 트랜잭션 보장함. 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야하는 경우도 있음. 트랜잭션은 시작하는 지점과 끝나는 지점이 있음. 끝나는 방법은 두 가지임. 트랜잭션 롤백(transaction rollback): 두개의 SQL이 있을 때 두번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우 앞에서 처리한 작업도 취소시켜야 함.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 5장 정리 - 1</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_5/</link>
      <pubDate>Sat, 14 Jan 2023 23:28:01 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_5/</guid>
      <description>5-1. 사용자 레벨 관리 기능 추가 정해진 조건에 따라 사용자의 레벨을 변경하는 기능 추가 5.1.1 필드 추가 Level 이늄 사용자 레벨을 이늄(enum)으로 정의 public enum Level { Basic(1), SILVER(2), GOLD(3); private final int value; Level(int value) { this.value=value; } public int intValue() { return value; } public static Level valueOf(int value) { switch(value) { case 1: return BASIC; case 2: return SILVER; case 3: return GOLD; default: throw new AssertionError(&amp;#34;Unknown value: &amp;#34;+ value&amp;#34;); } } } User 필드 추가 public class User { .</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 4장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_4/</link>
      <pubDate>Sun, 08 Jan 2023 02:31:22 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_4/</guid>
      <description>4.1 사라진 SQLException 4.1.1 초난감 예외처리 예외 블랙홀 - catch 문에 아무것도 넣지 않는 경우 무의미하고 무책임한 throws 예외 처리시 핵심 원칙 모든 예외는 적절하게 복구되거나 작업을 중단시키고 개발자에게 통보되어야 함. 4.1.2 예외의 종류와 특징 체크 예외(checked exception) - 명시적인 처리가 필요한 예외를 사용하고 다루는 법 자바에서 throw를 통해서 발생시킬 수 있는 예외 Error - java.lang.Error 클래스의 서브클래스들 시스템 레벨에서 특별한 작업을 하는게 아니라면 애플리케이션에서는 신경 쓰지 않아도 됨. Exception과 체크 예외 체크 예외 - Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 3장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_3/</link>
      <pubDate>Sun, 18 Dec 2022 00:13:50 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_3/</guid>
      <description>Intro 개방 폐쇄 원칙(OCP) : 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것 템플릿 : 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록하는 방법 3.1 다시 보는 초난감 DAO 3.1.1 예외처리 기능을 갖춘 DAO DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있음. → 예외처리 (예외가 발생할 경우 리소스를 반환하도록 만들어야함.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 2장 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_2/</link>
      <pubDate>Sun, 11 Dec 2022 03:37:39 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_2/</guid>
      <description>Intro 스프링의 핵심 = 객체지향 &amp;amp; 테스트 테스트 = 의도했던 대로 코드가 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업임. 2.1 UserDaoTest 다시 보기 2.1.2 UserDaoTest의 특징 작은 단위의 테스트
테스트하고자 하는 대상이 명확하면 대상에만 집중해서 테스트하는 것이 바람직함. → 테스트는 작은 단위로 쪼개서 집중 (관심사의 분리)
→ 단위 테스트(unit test)
자동수행 테스트 코드
테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요함. (자주 반복할 수 있다는 장점이 있음.) 2.1.3 UserDaoTest의 문제점 수동 확인 작업의 번거로움 테스트의 수행은 코드에의해 자동으로 진행되지만 확인하는 일은 사람의 책임.</description>
    </item>
    
    <item>
      <title>[백준] DP 1 - 2579번 계단 오르기</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_dp_1/</link>
      <pubDate>Sat, 10 Dec 2022 16:54:24 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_dp_1/</guid>
      <description>문제(link) DP로 해결하는 문제입니다.
풀이 방법 기본 조건 : 계단의 개수는 300이하의 자연수 arr = [0 for i in range(301)] dp = [0 for i in range(301)] 계단 오르기 규칙 1)1칸 or 2칸 오르기 가능 2)연속 3칸 밟기 불가능 3)마지막 칸 반드시 밟아야 함. → DP는 큰 문제를 작은 문제로 나누어 푸는 문제임.
어떤 큰 문제가 있을 때 그것의 가장 작은 문제부터 생각해야함.
→ 마지막 칸은 반드시 밟아야 하므로 다음과 같은 두 개의 경우의 수 존재함.</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 1.5~1.9 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_1/</link>
      <pubDate>Sat, 03 Dec 2022 21:57:55 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_1/</guid>
      <description>1.5 스프링의 IoC 스프링의 핵심 → 애플리케이션 컨텍스트(빈 팩토리) 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC 어플리케이션 컨텍스트와 설정정보
빈(bean) : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말 빈 팩토리(bean factory) : 빈의 생성과 관계 설정과 같은 제어를 담당하는 IoC 오브젝트 애플리케이션 컨텍스트 : 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업 총괄. IoC엔진이라는 의미가 부각됨.</description>
    </item>
    
    <item>
      <title>[백준] Brute Force 1- 18111번 마인크래프트</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_bruteforce_1/</link>
      <pubDate>Mon, 28 Nov 2022 14:48:17 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_bruteforce_1/</guid>
      <description>문제(link) 브루트포스 알고리즘으로 해결하는 문제입니다. 땅의 높이는 256블록을 초과할 수 없습니다. 층을 기준으로해서모든 경우의 수를 계산합니다. 층(target)과 같은 높이만큼 블록을 제거하거나 추가해서 (작업 최소 시간, 높이)를 구할 수 있습니다.
풀이 방법 [1] 0~256층까지 반복 [1-1] graph 좌표에 저장되어 있는 블록이 층 수보다 크거나 같으면 → 블록 제거, 인벤토리에 추가 [1-2] graph 좌표에 저장되어 있는 블록이 층 수보다 작으면 → 블록 추가, 인벤토리에서 제거 [1-3] 인벤토리 블록의 범위 안에서 작업했다면 [1-3-1] 최소 시간이라면 Update (작업 최소시간, 높이)</description>
    </item>
    
    <item>
      <title>[토비의 스프링 3.1] 1.1~1.4 정리</title>
      <link>http://slow-wave.github.io/post/spring/spring_toby_0/</link>
      <pubDate>Sat, 26 Nov 2022 00:08:02 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/spring/spring_toby_0/</guid>
      <description>스프링이란 무엇인가? 스프링은 자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크다. 스프링을 사용한다는 것은 다음의 세 가지 요소를 적극적으로 활용해서 애플리케이션을 개발한다는 뜻이다. 스프링 개발 철학 중 하나는 ‘항상 프레임워크 기반의 접근 방법을 사용하라’이다. 프레임워크의 가장 중요한 목적은 개발자가 일정한 틀을 따라 효과적으로 애플리케이션을 개발하도록 돕는 것이다. 따라서 프레임워크를 잘 이해하려면 프레임워크를 사용했을 때 애플리케이션 코드가 어떻게 만들어지는지 자세히 살펴봐야 한다. 1) 애플리케이션의 기본 틀 - 스프링 컨테이너 스프링은 스프링 컨테이너라고 불리는 스프링 런타임 엔진을 제공한다.</description>
    </item>
    
    <item>
      <title>[algorithm] 소수 판별</title>
      <link>http://slow-wave.github.io/post/algorithm/algo_prime/</link>
      <pubDate>Thu, 24 Nov 2022 01:14:27 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/algo_prime/</guid>
      <description>소수 판별 Intro 코딩테스트 문제를 풀다보면 가끔 소수 판별하는 문제가 나옵니다. 소수는 간단하게 정의하자면 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수입니다. 수학 시간에 소수를 많이 다뤘다보니 수를 보면 이 수는 소수인지 아닌지는 작은 수면 바로 판별이 가능하지만 이를 알고리즘으로 바꾸는 것은 좀 어려웠습니다.
다행히 소수 판별 문제를 해결하기 위한 대표적인 방법이 의미 정의 되어있습니다. 에라토스테네스의 체 알고리즘을 활용하는 것입니다. 이는 다수의 자연수에 대하여 소수 여부를 판별할 때 사용하는 대표적인 알고리즘이며 N보다 작거나 같은 모두 소수를 찾을 때 사용할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[MySQL] joins</title>
      <link>http://slow-wave.github.io/post/database/db_mysql_2/</link>
      <pubDate>Tue, 01 Nov 2022 16:24:19 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_mysql_2/</guid>
      <description>Table간 Join을 수행해야할 때는 다음과 같이 집합의 개념을 활용해서 생각하면 좋습니다. MySQL 언어로 아래의 모든 집합 관계에 대해서 표현해보려고 합니다.
MySQL JOINS 0. Full Outer Join [0] problem /* Input: Employees table: +-------------+----------+ | employee_id | name | +-------------+----------+ | 2 | Crew | | 4 | Haven | | 5 | Kristian | +-------------+----------+ Salaries table: +-------------+--------+ | employee_id | salary | +-------------+--------+ | 5 | 76071 | | 1 | 22517 | | 4 | 63539 | +-------------+--------+ Output: +-------------+ | employee_id | +-------------+ | 1 | | 2 | +-------------+ */ select Employees.</description>
    </item>
    
    <item>
      <title>[MySQL] 활용</title>
      <link>http://slow-wave.github.io/post/database/db_mysql_1/</link>
      <pubDate>Tue, 01 Nov 2022 16:21:10 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_mysql_1/</guid>
      <description>0) Second Highest Salary (problem) Input: Employee table: +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ Output: +---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ solution 1
SELECT max(Salary) as SecondHighestSalary FROM Employee WHERE Salary &amp;lt; (SELECT max(Salary) FROM Employee); solution 2 (n-th rank 구할 때 적절할 듯)
WITH CTE AS (SELECT Salary, RANK () OVER (ORDER BY Salary desc) AS RANK_desc FROM Employee) SELECT MAX(salary) AS SecondHighestSalary FROM CTE WHERE RANK_desc = 2 with 절 동일한 SQL 문이 반복되어 성능을 높이기 위해 사용됨.</description>
    </item>
    
    <item>
      <title>[MySQL] 문법/함수 정리</title>
      <link>http://slow-wave.github.io/post/database/db_mysql_0/</link>
      <pubDate>Fri, 21 Oct 2022 01:43:36 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_mysql_0/</guid>
      <description>코딩테스트 연습 할 때 Leetcode 플랫폼을 많이 이용합니다. discussion을 보면 문제에 대한 각자의 코드와 설명이 있는데 많은 사람들이 vote와 댓글 기능을 이용해 피드백을 줍니다. 보통은 칭찬이 많이 달려있는 글을 위주로 참고합니다. 별로인 것에 대해서는 가차없는 피드백이 적혀있다는 것도 도움이 되는 것 같습니다. 또 댓글로 시간복잡도 등에 대해서 토론하는 부분도 있어서 유용합니다.
개인적으로 SQL을 공부 할 필요성을 느껴서 MySQL의 문법을 중심으로 problem과 code를 정리해봤습니다. discussion을 꼼꼼히 읽어서 어떻게 코딩하는 것이 좋은 방향인지도 알아보려고 합니다.</description>
    </item>
    
    <item>
      <title>[config]Virtual Box, Vagrant를 이용한 가상 머신 환경 구축</title>
      <link>http://slow-wave.github.io/post/etc/etc_vm_0/</link>
      <pubDate>Fri, 21 Oct 2022 01:37:04 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/etc/etc_vm_0/</guid>
      <description>intro mac에서 virtualbox를 이용해 비교적 간단하게 ubuntu 환경을 구축하는 방법에 대한 글입니다.
virtualbox는 Oracle VM VirtualBox는 GPLv2 라이선스로 배포되는 오픈 소스 하드웨어 리소스 가상화 프로그램입니다. 일반 컴퓨터에 운영체제를 설치하고 프로그램을 실행할 수 있는 것처럼, 가상머신 위에도 운영체제를 설치하고 프로그램을 실행할 수 있습니다. Vagrant는 Mitchell Hashimoto가 Ruby로 개발하고 2010년 3월 처음 릴리스한 커맨드라인 인터페이스로 가상 머신 기반 개발 환경을 관리하는 도구입니다. 우분투(Ubuntu)는 가장 널리 쓰이는 오픈소스 리눅스 배포판 중 하나입니다.
아래 태스크들을 실행하기 전에 homebrew를 먼저 설치해야 합니다.</description>
    </item>
    
    <item>
      <title>[boostcourse 웹프로그래밍 풀스택] 1-2. browser의 동작</title>
      <link>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/</link>
      <pubDate>Fri, 14 Oct 2022 16:34:33 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/</guid>
      <description>Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS 이 글은 &amp;ldquo;How Browsers Work: Behind the scenes of modern web browsers&amp;ldquo;의 번역본을 정리한 것입니다.
1. broswer 1) broswer의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것입니다. 자원은 보통 HTML 문서이지만 다른 형태일 수 있으며, 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해집니다.
2) browser의 기본 구조 UI : 주소 표시줄, 이전/다음 버튼 등 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분입니다.</description>
    </item>
    
    <item>
      <title>[algorithm] MST(Minimum Spanning Tree)</title>
      <link>http://slow-wave.github.io/post/algorithm/algo_mst_1/</link>
      <pubDate>Thu, 13 Oct 2022 17:08:34 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/algo_mst_1/</guid>
      <description>0. Spanning Tree Spanning Tree란 그래프 내의 모든 정점을 포함하는 트리입니다. 즉, 그래프에서 일부 간선을 선택해서 만든 트리입니다. 이때 그래프에 사이클이 형성이 되면 안됩니다. 연결 그래프에 대한 spanning tree는 여러개 일 수 있습니다.
n개의 정점을 가지는 그래프의 최소 간선의 수는 (n-1)개이고, (n-1)개로 연결되어 있으면 필연적으로 트리 형태가 되고 이것이 spanning tree가 됩니다. 따라서 spanning tree는 그래프에 있는 n개의 정점을 (n-1)개의 간선으로 연결합니다.
1. Minimum Spanning Tree (MST) MST는 트리를 구성하는 간선들의 가중치를 합한 것이 최소가 되는 신장 트리이며 다음의 조건을 충족해야합니다.</description>
    </item>
    
    <item>
      <title>[data structure] 자료구조 정리</title>
      <link>http://slow-wave.github.io/post/data_structure/ds_intro/</link>
      <pubDate>Wed, 12 Oct 2022 17:04:59 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/data_structure/ds_intro/</guid>
      <description>0. Intro Data Structure는 데이터를 저장하고 구성하는데 사용하는 저장소입니다. 데이터에 효율적으로 접근하고 업데이트 할 수 있도록 컴퓨터에 데이터를 정렬하는 방법입니다.
Classification of Data Structure (출처)
Linear data structure란 데이터 요소가 순차적 또는 선형으로 배열되고 각 요소가 이전 및 다음 요소에 연결된 데이터 구조입니다. linear data structure에는 static과 dynamic 데이터 구조가 있습니다. static data structur의 경우 메모리 크기가 고정되어있고, dynamic data structure의 경우 메모리 크기가 고정되어있지 않습니다.
Non-linear data structure란 데이터 요소가 순차적 또는 선형으로 배치되지 않은 데이터 구조입니다.</description>
    </item>
    
    <item>
      <title>[deeplearing] CNN</title>
      <link>http://slow-wave.github.io/post/deeplearning/deeplearning_1/</link>
      <pubDate>Tue, 11 Oct 2022 16:04:21 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/deeplearning/deeplearning_1/</guid>
      <description>Fully Connected Layer fully connected layer만으로 구성된 인공신경망의 입력데이터는 1차원(배열) 형태로 한정됨. 한 장의 컬러 사진은 3차원 데이터임. (R,G,B) 따라서 사진 데이터로 Fully Connected 신경망을 학습시켜야할 경우, 3차원을 1차원으로 평면화시켜야함. 평면화를 시키면 공간 정보 손실 발생 → 신경망이 특징을 추출 및 학습할 때 정확도 높이는데 한계 이미지의 공간 정보를 유지한 상태로 학습이 가능한 모델이 CNN임. CNN(Convolution neural networks)이란? 합성곱(convolution) 이라는 연산을 사용하는 신경망 이미지 분류 작업에서 좋은 성능을 보여줌. 시각 피질에 대한 실험에서 얻은 데이터에서 영감을 얻은 특별한 구조를 사용함.</description>
    </item>
    
    <item>
      <title>[database] Re-introduction to DB</title>
      <link>http://slow-wave.github.io/post/database/db_programming_0/</link>
      <pubDate>Thu, 06 Oct 2022 00:50:00 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_programming_0/</guid>
      <description>데이터베이스 프로그래밍 수업의 내용을 정리한 문서입니다. 시간이 조금 지나고나서야 중요한 내용 임을 깨달아서 예전에 굿노트에 정리했던 것들을 다시 글로 기록하려고 합니다. 더 알고 싶은 부분은 조금 더 파고 들어볼 예정입니다.
1. DB 기본 개념 1) DB vs. DBMS DB는 저장된 데이터의 모임. 데이터 그 자체 컨텐츠를 의미함. DBMS는 데이터 접근을 위한 프로그램 set임. oracle MS SQL server MySQL MariaDB 2) Typical web-based application architecture [출처]
Client Tier - Presentation Layer 응용 프로그램의 최상단임 UI 제공 (인터넷 브라우저의 정적 데이터 제공) 주로 web server를 뜻 함 (물리적 WEB server) HTML, Javascript, CSS, Image Application Tier - Business Logic Layer 클라이언트 요청에 대해 마치 서버처럼 행동함 정보 처리의 규칙 존재(주로 동적 데이터임) middleware, backend 주로 application server 뜻함(물리적 WAS server) Data Tier - Data Access Layer DB와 엑세스해서 읽고 쓰고 관리하는 것을 포함 DB server (물리적 DB server) MySQL 3) Rational DB Domain : attribute가 가질 수 있는 값의 집합 Attribute(column) Tuple(record, row) Relation(table) DB - set of relations 4) Schema, Instance Schema : DB의 논리적 구조, 뼈대 Instance : DB의 실제 컨텐츠, DB의 상태 5) Key Key tuple을 구별하기 위한 attribute 집합 Superkey relation에서 unique하게 tuple을 식별할 수 있는 attribute 집합 Candidate Key superkey 중에서 minimal한 key Primary Key candidate key 중 하나 (relation을 정의할 때 선택) entity Integrity : Null이 될 수 없음.</description>
    </item>
    
    <item>
      <title>[blockchain] ch6. Transactions</title>
      <link>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch6/</link>
      <pubDate>Sun, 02 Oct 2022 23:11:22 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch6/</guid>
      <description>용어 정리 coinbase : 각 블록의 첫번째 트랜잭션이며 마이닝을 위한 보상. locking script : 출력에 배치되는 지출 조건. unlocking script : 출력을 사용할 수 있도록 하는 스크립트 P2PKH : 비트코인 내에서 가장 일반적인 스크립트 형식으로 거래 유형이다. digital signature : 개인키와 공개키암호를 이용한 전자서명이다. 이를 통해 본인임을 인증하고 수신인은 메세지가 위,변조 되지 않았음을 확인한다. SIGHASH : 데이터 가운데 어떤 부분 확인하고 서명해야하는지 지정해준다. Transaction outputs Transaction output은 불연속적이고 분리할 수 없다는 특징을 갖고 있다.</description>
    </item>
    
    <item>
      <title>[blockchain] ch5.Wallets</title>
      <link>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch5/</link>
      <pubDate>Sat, 01 Oct 2022 16:21:44 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch5/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Mnemonic codes word : Mnemonic code word는 Deterministic wallet을 도출하기위해 seed로 사용되는 임의의 숫자를 나타내는 단어 순서임. 랜덤 숫자에 비해 읽고 쓰기 쉬움. HD wallet : 비트코인의 BIP32표준으로 정의되어 현재 가장 발전된 형태의 지갑임. 하나의 마스터 시드 키에서 다수의 지갑을 생성할 수 있어 편리함. Nondeterministic Wallet (JBOK wallet, just a bunch of keys) 지갑 안에 있는 키 끼리 연관성 없음.</description>
    </item>
    
    <item>
      <title>[blockchain] ch4.Keys, Addresses</title>
      <link>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch4/</link>
      <pubDate>Fri, 30 Sep 2022 14:27:55 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch4/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Cryptography : 암호학 Public key : 공개키는 지정된 인증기관에 의해 제공되는 키 값이다. 공개키로부터 생성되는 개인키와 함께 결합되어 메시지 및 전자서명의 암호화와 복원에 사용할 수 있다. Private key : 개인키는 무작위로 추출된 숫자와 문자의 조합으로 이루어진 비밀번호와 같은 기능을 한다. elliptic curve multiplication(ECC, 타원곡선암호기술) : RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘 script : 스택 기반의 프로그래밍 언어이다.</description>
    </item>
    
    <item>
      <title>[blockchain] ch2. How bitcoin works</title>
      <link>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch2/</link>
      <pubDate>Thu, 29 Sep 2022 10:35:18 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/bc_mastering_bitcoin_ch2/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Decentralized : 탈중앙화. 분산된 소규모 단위로 자율적으로 운영되는 것. Mining : 채굴. 암호화폐의 거래내역을 기록한 블록을 생성하고 그 대가로 암호화폐를 얻는 행위. Peer-to-peer network : 인터넷에 연결된 다수의 개별 사용자들이 중개기관을 거치지 않고 직접 데이터를 주고받는 것. Consensus : 악의적인 상황이 발생하더라도 네트워크를 올바른 방향으로 이끌고자 하는 다수의 노드들이 상호 검증을 거쳐 올바른 블록 생성을 이끌어내는 프로세스와 알고리즘.</description>
    </item>
    
    <item>
      <title>[blockchain] blockchain의 개념</title>
      <link>http://slow-wave.github.io/post/blockchain/bc_intro/</link>
      <pubDate>Wed, 28 Sep 2022 16:06:51 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/bc_intro/</guid>
      <description>다음은 블록체인에 대한 기본적인 개념을 이해할 수 있었던 But how does bitcoin actually work? 영상을 보고 정리한 내용입니다.**
블록체인을 소유하고 있는건 어떤 의미일까? 비트코인을 만든다면?
먼저 친구들과의 금전 거래 내역을 공동의 장부에 기록한다. 장부를 믿으면 되니깐, 친구들과 세상에 대한 신뢰의 필요성은 점점 줄어든다. 신뢰가 없어도 장부로 거래를 운영할 수 있다면 그걸 암호화 화폐라고 부르지 않을까?
비트코인 = 최초의 암호화 화폐 은행 대신에 암호학에서 탄생된 몇 가지 수학 원리를 이용해서 거래 주체들 사이에 신뢰가 필요하지 않은 똑똑한 분산 확인 시스템이 있다.</description>
    </item>
    
    <item>
      <title>[Leetcode] Linked List 1 - 21. Merge Two Sorted Lists</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_linkedlist_1/</link>
      <pubDate>Tue, 13 Sep 2022 00:15:16 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_linkedlist_1/</guid>
      <description>[Leetcode] 21. Merge Two Sorted Lists 문제 링크
이 문제는 제목 그대로 2개의 리스트를 정렬해서 결합하는 문제입니다. 구현되어있는 ListNode class를 이용해서 mergeTwoLists method를 완성하면 됩니다.
풀이 과정 다음의 조건을 갖고 있다고 가정하고 실행 과정을 정리해보겠습니다.
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next a = [1,2,4] b = [1,3,4] dummy = cur = ListNode(0) Code (python) # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>[boostcourse 웹프로그래밍 풀스택] 1-1. HTTP 프로토콜의 이해</title>
      <link>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_0/</link>
      <pubDate>Tue, 06 Sep 2022 14:41:22 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_0/</guid>
      <description>Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS &amp;lsquo;[boostcourse 웹프로그래밍 풀스택]은&amp;rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.
깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다.</description>
    </item>
    
    <item>
      <title>[programmers] DFS/BFS 4- 순위</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_3/</link>
      <pubDate>Tue, 06 Sep 2022 14:23:31 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_3/</guid>
      <description>[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.
풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 3- 2667번 단지 번호 붙이기</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_2/</link>
      <pubDate>Tue, 23 Aug 2022 11:14:32 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_2/</guid>
      <description>[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.
[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.
[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.
[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 2- 2178번 미로탐색</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_1/</link>
      <pubDate>Fri, 19 Aug 2022 17:11:21 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_1/</guid>
      <description>[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.
Code (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx &amp;lt; 0 or ny &amp;lt; 0 or nx &amp;gt;= N or ny &amp;gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 1- 1260번 DFS와 BFS</title>
      <link>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_0/</link>
      <pubDate>Fri, 12 Aug 2022 22:29:58 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/ps_bfs_dfs_0/</guid>
      <description>[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.
방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!
풀이 방법 Graph &amp;lt;input&amp;gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.
DFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.</description>
    </item>
    
    <item>
      <title>[algorithm] DFS vs. BFS</title>
      <link>http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/</link>
      <pubDate>Wed, 10 Aug 2022 21:50:38 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/algo_bfs_vs_dfs/</guid>
      <description>Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.
DFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.
inorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.</description>
    </item>
    
  </channel>
</rss>
