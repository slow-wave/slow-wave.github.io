<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on slow-wave blog</title>
    <link>http://slow-wave.github.io/post/</link>
    <description>Recent content in Posts on slow-wave blog</description>
    <image>
      <url>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Oct 2022 14:30:28 +0900</lastBuildDate><atom:link href="http://slow-wave.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Test</title>
      <link>http://slow-wave.github.io/post/database/db_programming_2/</link>
      <pubDate>Thu, 06 Oct 2022 14:30:28 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_programming_2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[database] Re-introduction to DB</title>
      <link>http://slow-wave.github.io/post/database/db_programming_1/</link>
      <pubDate>Thu, 06 Oct 2022 00:50:00 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/database/db_programming_1/</guid>
      <description>데이터베이스 프로그래밍 수업의 내용을 정리한 문서입니다. 시간이 조금 지나고나서야 중요한 내용 임을 깨달아서 예전에 굿노트에 정리했던 것들을 다시 글로 기록하려고 합니다. 더 알고 싶은 부분은 조금 더 파고 들어볼 예정입니다.
1. DB 기본 개념 1) DB vs. DBMS DB는 저장된 데이터의 모임. 데이터 그 자체 컨텐츠를 의미함. DBMS는 데이터 접근을 위한 프로그램 set임. oracle MS SQL server MySQL MariaDB 2) Typical web-based application architecture [출처]
Client Tier - Presentation Layer 응용 프로그램의 최상단임 UI 제공 (인터넷 브라우저의 정적 데이터 제공) 주로 web server를 뜻 함 (물리적 WEB server) HTML, Javascript, CSS, Image Application Tier - Business Logic Layer 클라이언트 요청에 대해 마치 서버처럼 행동함 정보 처리의 규칙 존재(주로 동적 데이터임) middleware, backend 주로 application server 뜻함(물리적 WAS server) Data Tier - Data Access Layer DB와 엑세스해서 읽고 쓰고 관리하는 것을 포함 DB server (물리적 DB server) MySQL 3) Rational DB Domain : attribute가 가질 수 있는 값의 집합 Attribute(column) Tuple(record, row) Relation(table) DB - set of relations 4) Schema, Instance Schema : DB의 논리적 구조, 뼈대 Instance : DB의 실제 컨텐츠, DB의 상태 5) Key Key tuple을 구별하기 위한 attribute 집합 Superkey relation에서 unique하게 tuple을 식별할 수 있는 attribute 집합 Candidate Key superkey 중에서 minimal한 key Primary Key candidate key 중 하나 (relation을 정의할 때 선택) entity Integrity : Null이 될 수 없음.</description>
    </item>
    
    <item>
      <title>[blockchain] ch6. Transactions</title>
      <link>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch6/</link>
      <pubDate>Sun, 02 Oct 2022 23:11:22 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch6/</guid>
      <description>용어 정리 coinbase : 각 블록의 첫번째 트랜잭션이며 마이닝을 위한 보상. locking script : 출력에 배치되는 지출 조건. unlocking script : 출력을 사용할 수 있도록 하는 스크립트 P2PKH : 비트코인 내에서 가장 일반적인 스크립트 형식으로 거래 유형이다. digital signature : 개인키와 공개키암호를 이용한 전자서명이다. 이를 통해 본인임을 인증하고 수신인은 메세지가 위,변조 되지 않았음을 확인한다. SIGHASH : 데이터 가운데 어떤 부분 확인하고 서명해야하는지 지정해준다. Transaction outputs Transaction output은 불연속적이고 분리할 수 없다는 특징을 갖고 있다.</description>
    </item>
    
    <item>
      <title>[blockchain] ch5.Wallets</title>
      <link>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch5/</link>
      <pubDate>Sat, 01 Oct 2022 16:21:44 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch5/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Mnemonic codes word : Mnemonic code word는 Deterministic wallet을 도출하기위해 seed로 사용되는 임의의 숫자를 나타내는 단어 순서임. 랜덤 숫자에 비해 읽고 쓰기 쉬움. HD wallet : 비트코인의 BIP32표준으로 정의되어 현재 가장 발전된 형태의 지갑임. 하나의 마스터 시드 키에서 다수의 지갑을 생성할 수 있어 편리함. Nondeterministic Wallet (JBOK wallet, just a bunch of keys) 지갑 안에 있는 키 끼리 연관성 없음.</description>
    </item>
    
    <item>
      <title>[blockchain] ch4.Keys, Addresses</title>
      <link>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch4/</link>
      <pubDate>Fri, 30 Sep 2022 14:27:55 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch4/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Cryptography : 암호학 Public key : 공개키는 지정된 인증기관에 의해 제공되는 키 값이다. 공개키로부터 생성되는 개인키와 함께 결합되어 메시지 및 전자서명의 암호화와 복원에 사용할 수 있다. Private key : 개인키는 무작위로 추출된 숫자와 문자의 조합으로 이루어진 비밀번호와 같은 기능을 한다. elliptic curve multiplication(ECC, 타원곡선암호기술) : RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘 script : 스택 기반의 프로그래밍 언어이다.</description>
    </item>
    
    <item>
      <title>[blockchain] ch2. How bitcoin works</title>
      <link>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch2/</link>
      <pubDate>Thu, 29 Sep 2022 10:35:18 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch2/</guid>
      <description>Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.
용어 정리 Decentralized : 탈중앙화. 분산된 소규모 단위로 자율적으로 운영되는 것. Mining : 채굴. 암호화폐의 거래내역을 기록한 블록을 생성하고 그 대가로 암호화폐를 얻는 행위. Peer-to-peer network : 인터넷에 연결된 다수의 개별 사용자들이 중개기관을 거치지 않고 직접 데이터를 주고받는 것. Consensus : 악의적인 상황이 발생하더라도 네트워크를 올바른 방향으로 이끌고자 하는 다수의 노드들이 상호 검증을 거쳐 올바른 블록 생성을 이끌어내는 프로세스와 알고리즘.</description>
    </item>
    
    <item>
      <title>[blockchain] blockchain의 개념</title>
      <link>http://slow-wave.github.io/post/blockchain/blockchain_intro/</link>
      <pubDate>Wed, 28 Sep 2022 16:06:51 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/blockchain/blockchain_intro/</guid>
      <description>다음은 블록체인에 대한 기본적인 개념을 이해할 수 있었던 But how does bitcoin actually work? 영상을 보고 정리한 내용입니다.**
블록체인을 소유하고 있는건 어떤 의미일까? 비트코인을 만든다면?
먼저 친구들과의 금전 거래 내역을 공동의 장부에 기록한다. 장부를 믿으면 되니깐, 친구들과 세상에 대한 신뢰의 필요성은 점점 줄어든다. 신뢰가 없어도 장부로 거래를 운영할 수 있다면 그걸 암호화 화폐라고 부르지 않을까?
비트코인 = 최초의 암호화 화폐 은행 대신에 암호학에서 탄생된 몇 가지 수학 원리를 이용해서 거래 주체들 사이에 신뢰가 필요하지 않은 똑똑한 분산 확인 시스템이 있다.</description>
    </item>
    
    <item>
      <title>[Leetcode] Linked List 1 - 21. Merge Two Sorted Lists</title>
      <link>http://slow-wave.github.io/post/problem_solving/linkedlist_1/</link>
      <pubDate>Tue, 13 Sep 2022 00:15:16 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/linkedlist_1/</guid>
      <description>[Leetcode] 21. Merge Two Sorted Lists 문제 링크
이 문제는 제목 그대로 2개의 리스트를 정렬해서 결합하는 문제입니다. 구현되어있는 ListNode class를 이용해서 mergeTwoLists method를 완성하면 됩니다.
풀이 과정 다음의 조건을 갖고 있다고 가정하고 실행 과정을 정리해보겠습니다.
# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next a = [1,2,4] b = [1,3,4] dummy = cur = ListNode(0) Code (python) # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>[boostcourse 웹프로그래밍 풀스택] 1-1. HTTP 프로토콜의 이해 </title>
      <link>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/</link>
      <pubDate>Tue, 06 Sep 2022 14:41:22 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/</guid>
      <description>Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS &amp;lsquo;[boostcourse 웹프로그래밍 풀스택]은&amp;rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.
깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다.</description>
    </item>
    
    <item>
      <title>[programmers] DFS/BFS 4- 순위</title>
      <link>http://slow-wave.github.io/post/problem_solving/bfs_dfs_4/</link>
      <pubDate>Tue, 06 Sep 2022 14:23:31 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/bfs_dfs_4/</guid>
      <description>[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.
풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 3- 2667번 단지 번호 붙이기</title>
      <link>http://slow-wave.github.io/post/problem_solving/bfs_dfs_3/</link>
      <pubDate>Tue, 23 Aug 2022 11:14:32 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/bfs_dfs_3/</guid>
      <description>[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.
[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.
[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.
[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 2- 2178번 미로탐색</title>
      <link>http://slow-wave.github.io/post/problem_solving/bfs_dfs_2/</link>
      <pubDate>Fri, 19 Aug 2022 17:11:21 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/bfs_dfs_2/</guid>
      <description>[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.
Code (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx &amp;lt; 0 or ny &amp;lt; 0 or nx &amp;gt;= N or ny &amp;gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 1- 1260번 DFS와 BFS</title>
      <link>http://slow-wave.github.io/post/problem_solving/bfs_dfs_1/</link>
      <pubDate>Fri, 12 Aug 2022 22:29:58 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/problem_solving/bfs_dfs_1/</guid>
      <description>[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.
방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!
풀이 방법 Graph &amp;lt;input&amp;gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.
DFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.</description>
    </item>
    
    <item>
      <title>[algorithm] DFS vs. BFS</title>
      <link>http://slow-wave.github.io/post/algorithm/bfs_vs_dfs/</link>
      <pubDate>Wed, 10 Aug 2022 21:50:38 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/bfs_vs_dfs/</guid>
      <description>Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.
DFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.
binary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.
inorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.</description>
    </item>
    
  </channel>
</rss>
