[{"content":"Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.\n용어 정리 Cryptography : 암호학 Public key : 공개키는 지정된 인증기관에 의해 제공되는 키 값이다. 공개키로부터 생성되는 개인키와 함께 결합되어 메시지 및 전자서명의 암호화와 복원에 사용할 수 있다. Private key : 개인키는 무작위로 추출된 숫자와 문자의 조합으로 이루어진 비밀번호와 같은 기능을 한다. elliptic curve multiplication(ECC, 타원곡선암호기술) : RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘 script : 스택 기반의 프로그래밍 언어이다. 비트코인은 스크립트로 작성된 코드를 읽어 이를 실행하면서 코인 트랜잭션을 수행한다. P2SH(pay to script hash) : 공개키가 아닌 스크립트 해시에 지불하는 개념으로, 하나의 공개키로 해싱하는 것이 아닌 여러 공개키가 함께 해싱하여 출력하는 개념이다. Introduction 비트코인의 소유권은 digital keys, bitcoin addresses, digital signatures을 통해서 구성된다. digital key들은 네트워크에 저장되어있지 않고 파일안에서 소유자들에의해 저장되고 생성되거나 wallet이라고 부르는 단순한 DB에 저장된다. 소유자의 지갑안에있는 digital key들은 비트코인 프로토콜과 완전히 독립되어있으며 블록체인이나 인터넷을 통한 방법 없이 소유자의 지갑에의해 운영되고 생성될 수 있다. Key들에는 분산형 신뢰와 제어, 소유권 증명, 그리고 암호학 증명 안전 모델을 포함한다. 대부분의 비트코인 거래는 유효한 디지털 서명이 블록 체인에 포함되어야 하며, 이것은 비밀 키를 통해서만 생성될 수 있기 때문에, 그 키의 복사본을 가진 사람은 누구나 비트코인을 제어할 수 있다.\n자금을 소비하기위해 사용되는 디지털 서명은 *witness(*증인)라고도 한다. 비트코인 거래에서 witness 데이터는 사용중인 자금의 진정한 소유권을 인정한다. key들은 개인키와 공개키로 구성되는 쌍으로 제공된다. 공개키에 대해서 생각해보면 은행 계좌번호와 비슷하고 개인키는 비밀 PIN 또는 수표의 서명과 비슷하다. 비트코인 거래의 결제 부분에서, 수신자의 공개키는 디지털 지문, 즉 수표의 수익자 이름과 동일한 방식으로 사용되는 비트코인 주소로 보내진다. 대부분의 경우 비트코인 주소는 공개키에서 생성된다. 하지만 비트코인 주소들이 다 공개키를 나타내진 않는다.\n다음과 같은 내용에 대해서 알아볼 것이다.\ncryptography와 비트코인에서 사용되는 수학을 설명 어떻게 Keys가 생성, 저장, 관리되는지 Public key cryptography and cryptocurrency 공개키 암호학은 1970년대에 발명되었으며 정보보안과 컴퓨터를 위한 수학적 기반이다. 공개키 암호학의 발전 덕분에 수학적 함수들이 발견됐는데 이러한 것들을 바탕으로 암호학은 digital secrets와 unforgeable한 디지털 서명의 생성을 가능하게했다. 비트코인은 암호학의 기초로 curve multiplication을 사용한다.\n비트코인에서는 공개키 암호법을 사용하여 비트코인에 대해 엑세스를 제어하는 키 쌍을 만든다. 키 쌍은 개인키와 그로 부터 파생된 unique한 공개키로 구성된다. 공개키는 자금을 받기위해 사용되며 개인키는 자금을 소비하기위해 거래들에 싸인하기위해 사용된다.\n공개키와 개인키 사이에있는 수학적 관계가 있어 개인키를 사용하여 메시지에 서명을 생성할 수 있다. 이 서명은 개인키를 공개하지 않고 공개키에 대해 검증할 수 있다. 공개키와 서명을 통해, 비트코인 네트워크에 있는 모든 사람이 이 거래가 유효한지 확인하고 받아들일 수 있으며, 이는 전송 당시 비트코인을 양도한 사람이 이 거래를 소유하고 있었음을 확인시켜준다.\nPrivate and Public Keys\n비트코인 지갑에는 각각 개인키와 공개키로 구성된 키 쌍이 들어 있다.\n개인키(k)는 일반적으로 무작위로 선택하는 숫자다. 이전 개인키에서 단방향 암호화 함수인 elliptic curve multiplication(타원 곡선 곱셈)을 사용하여 공개키(K)를 생성한다. 공개키(K)에서 단방향 암호화 해시 함수를 사용하여 비트코인 주소(A)를 생성한다.\nPrivate keys\n개인키는 랜덤한 숫자다. 개인 키는 거래에 사용되는 펀드의 소유권을 증명하여 비트코인을 소비하는 데 필요한 서명을 만드는 데 사용된다. 개인키를 제3자에게 공개하는 것은 그들에게 그 키로 확보한 비트코인에 대한 통제권을 주는 것과 같다.\nGenerating a private key from a random number 비트코인 클라이언트로 새 키를 생성하려면 → getnewaddress 비트코인에 개인키 노출 요청 → dumprivkey Public keys 공개키는 되돌릴 수 없는 elliptic curve multiplication을 사용하여 개인키에서 계산된다. elliptic curve multiplication은 \u0026rsquo;trap door\u0026rsquo; 라고 부르는 함수의 한 종류다. 한 방향으로(곱셈)수행이 쉽고 역방향 수행(나누기)이 불가능하다. 개인키의 소유자는 공개키를 쉽게 만든 다음 다른 사람이 공개키에서 개인키를 계산할 수 없다는 것을 알고 다른 사람들과 공유할 수 있다.\nGenerating a public key K=k*G (k = 개인키, G = generator point, K = 결과 공개키이며 곡선의 점.)\n생성기 포인트는 모든 비트코인 사용자에게 항상 동일하기 때문에, 개인키 k에 G를 곱하면 항상 동일한 공개키 K가 된다. K와 K 사이의 관계는 고정적이지만, k에서 K까지 한 방향으로만 계산될 수 있다. 이것이 (K에서 파생된) 비트코인 주소를 누구와도 공유할 수 있고 사용자의 개인키(k)를 공개하지 않는 이유이다. 개인키는 공개키로 변환할 수 있지만 수학은 한가지 방식으로만 작동하므로 공개키는 개인키로 변환할 수 없다.\nBitcoin Addresses 비트코인 주소는 당신에게 돈을 보내기를 원하는 누구와도 공유될 수 있는 숫자와 문자의 연속이다. 공개 키로 생성된 주소는 숫자 \u0026ldquo;1\u0026quot;로 시작하는 일련의 숫자와 문자로 구성된다.\n비트코인 주소는 단방향 암호화 해싱을 통해 공개키에서 파생된다. \u0026ldquo;해싱알고리즘\u0026rdquo; 은 임의의 크기의 입력의 지문이나 \u0026ldquo;해시\u0026quot;를 생성하는 단방향 함수이다. 공개키로 비트코인 주소를 만드는 데 사용되는 알고리즘은 보안 해시 알고리즘(SHA)과 RACE 무결성 기본 요소 평가 메시지 다이제스트(RIPEMD), 특히 SHA256 및 RIPEMD160가 있다.\n비트코인 주소는 거의 항상 \u0026ldquo;Base58Check\u0026quot;로 인코딩되며, checksum을 사용하여 인간의 가독성을 돕고, 모호성을 방지하며, 주소 전사 및 입력의 오류로부터 보호한다.\nBase58 and Base58check encoding Base58은 텍스트 기반 바이너리 인코딩 형식으로, 비트코인에 사용하기 위해 개발되었으며 다른 많은 암호 화폐에 사용된다. 오타나 전사 오류에 대한 보안을 강화하기 위해 Base58Check는 Base58 인코딩 형식으로, 오류 검사 코드가 내장되어 있는 비트코인에 자주 사용된다. checksum은 인코딩 중인 데이터의 끝에 추가된 4bytes이다. checksum은 인코딩된 데이터의 해시로부터 파생되므로 전사 및 입력 오류를 감지하고 방지하는 데 사용할 수 있다.\nPay-to-Script Hash(P2SH) and Multisig Addresses P2SH 주소는 트랜잭션 출력을 사용할 수 있는 사용자를 정의하는 트랜잭션 스크립트에서 생성된다. P2SH 주소 인코딩에는 비트코인 주소 생성 시 사용된 것과 동일한 더블 해시 함수를 사용하는 것이 포함되며, 공용키 대신 스크립트에만 적용된다.\n현재 P2SH 기능의 가장 일반적인 구현은 Multisignature addresses이다. 기본 스크립트는 소유권을 증명하고 따라서 자금을 지출하기 위해 둘 이상의 서명을 필요로 한다.\nVanity addresses vanity 주소는 사람이 읽을 수 있는 메시지를 포함하는 유효한 비트코인 주소이다. vanity 패턴으로 시작하는 주소의 개인 키는 다른 주소보다 쉽게 찾을 수 없다.\n","permalink":"http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch4/","summary":"Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.\n용어 정리 Cryptography : 암호학 Public key : 공개키는 지정된 인증기관에 의해 제공되는 키 값이다. 공개키로부터 생성되는 개인키와 함께 결합되어 메시지 및 전자서명의 암호화와 복원에 사용할 수 있다. Private key : 개인키는 무작위로 추출된 숫자와 문자의 조합으로 이루어진 비밀번호와 같은 기능을 한다. elliptic curve multiplication(ECC, 타원곡선암호기술) : RSA의 대안으로 대두된 이산대수의 난해성에 기반한 공개키 암호화 알고리즘 script : 스택 기반의 프로그래밍 언어이다.","title":"[blockchain] ch4.Keys, Addresses"},{"content":"Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.\n용어 정리 Decentralized : 탈중앙화. 분산된 소규모 단위로 자율적으로 운영되는 것. Mining : 채굴. 암호화폐의 거래내역을 기록한 블록을 생성하고 그 대가로 암호화폐를 얻는 행위. Peer-to-peer network : 인터넷에 연결된 다수의 개별 사용자들이 중개기관을 거치지 않고 직접 데이터를 주고받는 것. Consensus : 악의적인 상황이 발생하더라도 네트워크를 올바른 방향으로 이끌고자 하는 다수의 노드들이 상호 검증을 거쳐 올바른 블록 생성을 이끌어내는 프로세스와 알고리즘. PoW(Proof of Work) : 작업 증명. 최초의 consensus 알고리즘. 블록 생성 시간동안 가장 많은 해시파워를 제공한 노드가 블록을 생성하도록 설계. Introduction 비트코인은 탈중앙화된 신뢰에 기반하며 비트코인에서 신뢰는 다른 참여자들간의 상호작용으로부터 달성된다. 거래가 비트코인 시스템을 통해 추적하고 분산된 합의(distributed consensus)의 메커니즘에 의해 신뢰되고 받아들여지며 최종적으로 모든 transaction의 ledger인 blockchain에 기록되는 것을 관찰할것이다. 비트코인 시스템은 키를 포함한 지갑을 갖고 있는 users, network를 통해 전파되는 transactions, miners 로 구성된다.\nTransaction Inputs and outputs 각 transaction은 하나 이상의 input을 포함하고 있는데 이것은 비트코인 계정에 대한 debit과 같다. transaction의 다른 한 쪽에는 하나 이상의 output이 있는데 이것은 비트코인 계정에 추가된 credit과 같다. input(debit) \u0026amp; output(credit)의 양은 반드시 같지는 않다. transaction은 또한 소유권 증명(proof of ownership)을 포함한다. 비트코인에서 spending은 이전 transaction의 가치를 비트코인 주소로부터 식별된 새로운 소유자에게 이전하는 거래에 서명하는 것이다.\nMaking Change 많은 비트코인 트랜잭션들은 새로운 소유자와 현재 소유자의 주소와 변경 주소 모두를 참조하는 output들을 포함할 것이다. 그 이유는 트랜잭션 input들은 통화 지폐와 같이 나눠질 수 없기 때문이다. 만약 주머니에서 가장 큰 지폐를 사용했다면 잔돈으로 가득찬다. 잔돈만 사용한다면 고액권만 갖게된다. 사람들은 무의식적으로 이 두 극단 사이의 균형을 찾고, 비트코인 지갑 개발자들은 이 균형을 프로그램하기 위해 노력한다.\ntransaction들은 transaction input에서 transaction output으로 값을 이동한다. input은 이전 transaction의 output의 참조로, 값이 어디서 왔는지 보여준다. 가치가 소유자에서 소유자로 이동될 때 chain of ownership을 만든다.\nCommon Transaction Forms 가장 일반적인 형태는 한 주소에서 다른 주소로의 지불 원래 소유자에게 반환된 \u0026lsquo;변경\u0026rsquo;을 포함한다. 이런 형식의 transaction은 하나의 input과 두개의 output을 가지고 있다. 여러 입력을 하나의 단일 output으로 통합 하나의 input을 여러 수신자를 나타내는 다량의 ouput에 분배하는 거래 Constructing a transaction-Getting the Right inputs fully-node client로 운영되는 비트코인 지갑은 블록체인 상의 모든 사용되지 않은 output의 복사본을 포함한다.\nAdding the Transaction to the ledger-Transmitting the transaction 트랜잭션이 진행되는데 필요한 모든 정보를 가지고 있기 때문에 비트코인 네트워크에서 어떻게 그리고 어디서 전송되는지는 상관할 바가 아니다.\n비트코인 네트워크는 peer-to-peer 네트워크이다. 비트코인 네트워크의 목적은 거래와 블록을 모든 참가자들에게 전파하는 것이다.\nHow it propagates 비트코인 네트워크에 참여하는 모든 시스템은 비트코인 노드라고 한다. 이전에 보지 못한 유효한 트랜잭션을 수신하는 모든 비트코인 노드는 \u0026lsquo;flooding\u0026rsquo;으로 알려진 전파기술을 통해 연결된 모든 다른 노드로 바로 포워딩된다.\nBitcoin Mining Alice의 transaction은 비트코인 네트워크에서 전파되고 있다. mining이라고 불리는 과정을 통해 검증되고 블럭에 포함되기 전까지는 블록체인의 일부가 되지 않은 것이다. 트랜잭션은 블록으로 번들되는데, 이를 증명하려면 엄청난 양의 계산이 필요하지만 입증된 대로 검증하는데는 적은 양의 연산만 필요하다.\nmining 과정은 비트코인에서 두가지 목적으로 사용된다.\nmining nodes가 비트코인의 \u0026lsquo;consensus rules(합의 규칙)\u0026lsquo;을 참조하여 모든 거래들을 검증한다. mining은 유효하지 않거나 잘못된 거래들을 거절함으로써 비트코인 거래들에 보안을 제공한다. 거의 중앙 은행이 새로운 돈을 발행하는 것과 같이 각 블록에 새로운 비트코인을 만든다. 블록당 생성되는 비트코인의 양은 제한되어있으며, 정해진 발행 일정에 따라 시간이 지남에 따라 감소한다. mining은 비용과 보상 사이에서 좋은 균형을 이룬다. 성공적인 miner는 새로운 비트코인과 거래 수수료의 형태로 보상을 수집할 것이다. 그러나 보상은 miner가 합의 규칙을 만족시키기 위해 모든 거래를 올바르게 검증한 경우에만 수집될 것이다. 이 사소한 균형은 중앙의 권위없이 비트코인의 보안을 제공한다.\n비트코인에 사용되는 \u0026lsquo;퍼즐\u0026rsquo;은 암호화 그래픽 해시를 기반으로 하며, 비대칭적으로 해결하기 어렵지만 검증하기 쉽고, 난이도 조정이 가능하다는 유사한 특징을 보인다. PoW를 위한 알고리즘은 솔루션이 사전결정된 패턴과 일치하는 솔루션이 나타날 때까지 SHA256 암호화 그래픽 알고리즘으로 블록 헤더와 난수를 반복 해시하는 것을 포함한다. 이러한 솔루션을 최초로 발견한 마이너는 경쟁에서 이겨 해당 블록을 블록체인에 게시한다. 더 많은 miner들이 비트코인 네트워크에 참여하기시작할수록 문제의 어려움은 급격히 증가한다.\nMining Transactions in Blocks 마이너는 새 블록을 구성할 때 이 풀에서나온 비식별된 거래들을 새로운 블럭에게 더하고 PoW 마이닝 알고리즘을 활용해 새로운 블럭의 유효성을 검증한다.\nSpending the Transaction 각 비트코인 클라이언트는 거래가 유효하고 사용가능한지를 확인할 수 있다. lightweight 클라이언트들은 거래가 블록체인에 있고 그 후에 채굴된 여러 블록을 가지고 있다는 것을 확인함으로써 소위말하는 단순결제검증(Simplified Payment Verification)을 수행할 수 있으며, 채굴자들이 이를 유효하다고 보장할 수있다.\n출처 해시넷 [책] Mastering Bitcoin: Programming the Open Blockchain 2nd Edition ","permalink":"http://slow-wave.github.io/post/blockchain/mastering_bitcoin_ch2/","summary":"Mastering Bitcoin: Programming the Open Blockchain 2nd Edition 책을 정리한 내용입니다.\n용어 정리 Decentralized : 탈중앙화. 분산된 소규모 단위로 자율적으로 운영되는 것. Mining : 채굴. 암호화폐의 거래내역을 기록한 블록을 생성하고 그 대가로 암호화폐를 얻는 행위. Peer-to-peer network : 인터넷에 연결된 다수의 개별 사용자들이 중개기관을 거치지 않고 직접 데이터를 주고받는 것. Consensus : 악의적인 상황이 발생하더라도 네트워크를 올바른 방향으로 이끌고자 하는 다수의 노드들이 상호 검증을 거쳐 올바른 블록 생성을 이끌어내는 프로세스와 알고리즘.","title":"[blockchain] ch2. How bitcoin works"},{"content":"다음은 블록체인에 대한 기본적인 개념을 이해할 수 있었던\nBut how does bitcoin actually work? 영상을 보고 정리한 내용입니다.**\n블록체인을 소유하고 있는건 어떤 의미일까? 비트코인을 만든다면?\n먼저 친구들과의 금전 거래 내역을 공동의 장부에 기록한다. 장부를 믿으면 되니깐, 친구들과 세상에 대한 신뢰의 필요성은 점점 줄어든다. 신뢰가 없어도 장부로 거래를 운영할 수 있다면 그걸 암호화 화폐라고 부르지 않을까?\n비트코인 = 최초의 암호화 화폐 은행 대신에 암호학에서 탄생된 몇 가지 수학 원리를 이용해서 거래 주체들 사이에 신뢰가 필요하지 않은 똑똑한 분산 확인 시스템이 있다.\n장부(ledger)와 디지털서명(digital signature) 돈을 주고 받을 때는 누구나 볼 수 있는 공동 장부에 기록한다. 그리고 모두 모여서 거래 내역을 보고 정산을 한다.\n이 시스템의 프로토콜을 간단히 정리하면 다음과 같다.\n누구든 장부에 기록 가능하다. 매달 말 일에 모여서 정산한다. 문제점1. 아무나 기록할 수 있다. 공동 장부에 기록된 내용들이 돈을 보내는 사람의 의도대로 진실되게 기록되어있다는 것을 어떻게 믿을 수 있을까? ⇒ 디지털 서명\n돈을 보낸다는 거래 기록에 서명 같은 효과를 가지는 무언가를 추가할 수 있어야한다. 물론 위조도 불가능해야한다.\n위조를 막기위해서는 private key - public key를 생성한다. 디지털 서명은 보통 256개의 0과 1의 조합으로 만들어진 하나의 값이다. (디지털 서명의 값 = 문서의 내용 + 비밀키를 조합하는 함수에 의해 만들어짐.) →누군가 디지털 서명값을 훔쳐도 다른 문서에 대한 증표로는 사용될 수 없음.\n디지털 서명과 관련된 두번째 함수는 디지털 서명값이 유효한지 확인하는데 사용된다. 두번째 함수는 단순하게 참 또는 거짓만을 결과값으로 반환한다. 비밀키를 모른다면 유효한 디지털 서명값을 찾아낼 수 없다. 비밀키를 모르면 아무 값이나 디지털 서명값으로 정하고, 공개키와 함께 계산해서 디지털 서명값이 유효한지 확인하는 것을 반복하는 것 외에는 방법이 없다. 이 경우의 수는 2^256 개이므로 디지털 서명값이 유효하다고 확인되는 것은 충분히 확신해도 된다.\n문제점2. 디지털 서명값을 위조할 수는 없지만, 동일한 거래 내역 자체는 여러번 복사할 수 있다. → 메시지에 거래별로 유일한 식별자인 ID값을 포함해야한다. 그렇게하면 메시지 내용이 다르므로 디지털 서명값도 달라져 복사해도 다른 곳에 쓸 수 없게 된다.\n문제점3. 어떤 사람이 수천 달러 지불한다는 거래기록을 장부에 남기고 먹튀를 한다면? → 자기들이 미리 적립해둔 금액 이상으로는 지출할 수 없게 한다. → 그 시점까지의 거래 내역 전부를 알아야만 한다는 제약이 생긴다.\n장부는 해당 통화의 모든 거래 이력만을 가지고 있을 뿐, 환전을 기록하지는 않는다. 비트코인에서도 사람들이 현금으로 비트코인을 사더라도, 장부에 실질적인 돈이 들어오는 것은 아니다.\n장부에 새로운 내용을 추가하는 것도 중앙의 누군가가 통제하는 걸까? 중앙의 누군가에게 의지하지 않으려면 모든 사람들이 장부의 복사본을 가지고 있어야된다. 장부를 가지고 있는 모든 사람들에게 거래를 알려야한다. 문제점4. 수많은 장부 중에서 어떤 장부가 올바른 장부인지를 어떻게 알 수 있을까? 우리 뿐만아니라 다른 모든 사람들도 똑같은 거래를 똑같은 순서로 그들의 장부에 기록해서 모든 사람들의 장부 내용이 언제나 완전히 같다는 것을 확신할 수 있을까? → 가장 많은 계산 작업을 포함하는 장부가 신뢰할만한 좋은 장부다. (암호화 해쉬함수) 무엇을 신뢰할 것인가를 판단하는 기준을 계산 작업에 둔다면, 거래 내역을 속이거나 장부의 충돌을 막기위해서는 정해진 시간 내에 처리가 불가능할만큼 엄청난 양의 계산이 필요하게 만들 수 있다.\n매직넘버를 찾아내는 일은 엄청난 계산이 필요하지만 매직 넘버가 맞는 값인지 확인하는 것은 별로 많은 양의 계산이 필요하지 않다.\n→ 작업 증명 (PoW)\n비트코인 논문의 핵심 아이디어는 장부를 가진 모든 사람들은 가장 많은 계산 작업이 포함된 장부를 믿으면 된다는 것이다. 장부는 블록 단위로 나누어서 구성되어있고, 블록에는 일정한 수의 거래 내역이 작업증명(매직넘버)과 함께 담겨 있으며 그 블록의 해쉬값은 정해진 만큼의 여러 자리수의 0으로 시작한다.\n거래는 지불하는 송금자의 디지털 서명이 있어야만 유효한 거래로 인식되는 것처럼 블록도 마찬가지로 작업 증명이 있어야만 유효한 블록으로 인식될 수 있다. 더 나아가서 블록들의 순서까지 보장하려면 각 블록이 자기보다 앞에있는 이전 블록의 해쉬값을 포함하게하면된다.\n→ 블록은 이렇게 앞의 블록의 해쉬값을 통해 앞뒤가 연쇄적으로 연결되어있기 때문에 그냥 장부라고 부르지 않고 블록체인이라고 한다.\n체인을 이루도록 변경된 규약에 의해, 이제는 누구든지 블록을 생성할 수 있게되었다. 누구든지 브로드캐스팅 되는 거래 정보를 접수하고 접수한 거래 정보를 모아서 블록을 만들고 그 블록의 해쉬값이 60개의 0으로 시작하게하는 매직 넘버를 찾기 위해 엄청난 양의 계산작업을 수행하고 마침내 그 매직 넘버를 찾아내서 그 블록을 브로드캐스팅하면 블록의 생성자가 된다.\n블록 보상 블록을 생성하고 보상을 받는 것을 채굴이라고 한다. 채굴자들이 실제로 하는 일은 브로드캐스팅 되는 거래 정보를 수집하고, 블록을 새로 생성해서, 생성한 새 블록을 다시 브로드캐스팅하고 보상을 받는 일이다. ","permalink":"http://slow-wave.github.io/post/blockchain/blockchain_intro/","summary":"다음은 블록체인에 대한 기본적인 개념을 이해할 수 있었던\nBut how does bitcoin actually work? 영상을 보고 정리한 내용입니다.**\n블록체인을 소유하고 있는건 어떤 의미일까? 비트코인을 만든다면?\n먼저 친구들과의 금전 거래 내역을 공동의 장부에 기록한다. 장부를 믿으면 되니깐, 친구들과 세상에 대한 신뢰의 필요성은 점점 줄어든다. 신뢰가 없어도 장부로 거래를 운영할 수 있다면 그걸 암호화 화폐라고 부르지 않을까?\n비트코인 = 최초의 암호화 화폐 은행 대신에 암호학에서 탄생된 몇 가지 수학 원리를 이용해서 거래 주체들 사이에 신뢰가 필요하지 않은 똑똑한 분산 확인 시스템이 있다.","title":"[blockchain] blockchain의 개념"},{"content":"[Leetcode] 21. Merge Two Sorted Lists 문제 링크\n이 문제는 제목 그대로 2개의 리스트를 정렬해서 결합하는 문제입니다. 구현되어있는 ListNode class를 이용해서 mergeTwoLists method를 완성하면 됩니다.\n풀이 과정 다음의 조건을 갖고 있다고 가정하고 실행 과정을 정리해보겠습니다.\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next a = [1,2,4] b = [1,3,4] dummy = cur = ListNode(0) Code (python) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = cur = ListNode(0) while list1 and list2: if list1.val \u0026lt; list2.val: cur.next = list1 list1 = list1.next else: cur.next = list2 list2 = list2.next cur = cur.next cur.next = list1 or list2 return dummy.next 자료 [1] python 변수 할당의 개념\n[2] Leetcode solution 1\n","permalink":"http://slow-wave.github.io/post/problem_solving/linkedlist_1/","summary":"[Leetcode] 21. Merge Two Sorted Lists 문제 링크\n이 문제는 제목 그대로 2개의 리스트를 정렬해서 결합하는 문제입니다. 구현되어있는 ListNode class를 이용해서 mergeTwoLists method를 완성하면 됩니다.\n풀이 과정 다음의 조건을 갖고 있다고 가정하고 실행 과정을 정리해보겠습니다.\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next a = [1,2,4] b = [1,3,4] dummy = cur = ListNode(0) Code (python) # Definition for singly-linked list.","title":"[Leetcode] Linked List 1 - 21. Merge Two Sorted Lists"},{"content":" Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS \u0026lsquo;[boostcourse 웹프로그래밍 풀스택]은\u0026rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.\n깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다. 그래서 원래 강의안의 전체적인 구조를 그대로 가져오되, 개인적으로 깊게 파고 들어본 내용을 더해서 정리하려고 합니다.\n1-1. HTTP 프로토콜의 이해 HTTP (Hypertext Transfer Protocol) 정의 HTTP는 서버와 클라이언트가 인터넷 상에서 데이터를 주고받기 위한 프로토콜입니다. 프로토콜은 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되었습니다. 오늘날에는 거의 모든 파일 형식을 HTTP 형식을 이용해 전송 가능합니다.\nHTTP 특징 HTTP 통신은 connectionless를 기본 동작으로 가집니다. connection을 유지하게되면 지속적으로 resource가 사용되기 때문입니다. 따라서 connection 유지는 최소화되는 것이 좋습니다.\nHTTP 작동 방식 HTTP 프로토콜로 데이터를 주고 받기 위해서는 Request를 보내고 Response를 받아야합니다. Client는 요청을 보내는 쪽을 의미하며 웹 관점에서는 브라우저를 의미합니다. Server는 요청을 받는 쪽을 의미하며 일반적으로 데이터를 보내주는 원격지의 컴퓨터를 의미합니다.\nServer-Client 모델 Server-Client는 1:N 구조로 연결되어 있으며 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신입니다. 즉, 한 대의 서버에 다수의 클라이언트가 접속하여 서비스를 이용합니다. 다수의 사용자들이 공동으로 열람·복사·수정·관리하는 데이터를 여러 곳에 분산시키지 않고 단일한 중앙 서버에 저장하여 관리함으로써 데이터의 유일성과 통일성을 보장할 수 있습니다.\nHTTP 프로토콜로 클라이언트가 서버에 요청을 보내고 성공적으로 데이터를 받게되면 동시에 서버와의 연결이 해체되고 보내진 데이터의 결과도 동시에 잃어버리게 됩니다. 이를 Stateless protocol 이라고 부르며 문제를 해결하기 위해 cookie, session, token 기술이 등장했습니다.\nClient란? 네트워크를 이용하여 서버 시스템에 연결된 PC나 스마트폰 등 사용자 측을 의미합니다. Client는 서버에서 받아온 데이터를 단말기 화면에 표시하고 사용자의 요청을 서버에 전달하기 위해 웹브라우저를 사용합니다.\nserver란? 통신망 상에서 다른 컴퓨터에 대해서 회선, 디스크 장치에 대한 접속을 제어하는 소프트웨어 혹은 컴퓨터입니다. web server, WAS, DB server 등이 있습니다.\n참고 자료 [1] 프런트엔드 개발자가 알아야하는 HTTP 프로토콜 Part 1\n[2] 서버-클라이언트\n[3] Http Stateless / cookie / session / token\n[4] Client-Server Model\n[5] HTTP(Hypertext Transfer Protocol)의 특징\n","permalink":"http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/","summary":"Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS \u0026lsquo;[boostcourse 웹프로그래밍 풀스택]은\u0026rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.\n깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다.","title":"[boostcourse 웹프로그래밍 풀스택] 1-1. HTTP 프로토콜의 이해 "},{"content":"[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.\n풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다. 자기 자신을 제외하고 모든 노드에 대해서 승패 여부를 알 수 있을 때만 확실한 순위를 알 수 있습니다.\n만약 5번 노드가 1~4번 노드에 대해서 패배했다면 순위는 5위가 됩니다. 만약 2번 노드가 1,3,4에게 패배하고 5에게 승리했다면 순위는 4위가 됩니다.\n따라서 주어진 정보를 가지고 노드 전체에 대한 승패를 표시하면 답을 구할 수 있습니다.\n자세한 풀이 과정은 다음과 같습니다. 최종 graph의 형태는 다음과 같습니다. 확실한 순위를 알 수 있는 노드는 2,5번으로 총 2개 입니다.\nCode (python) def dfs(graph): #1~N번 노드에 대해서 for target in range(1,n+1): #target 노드가 이긴 노드들을 담음 stack = [i for i, rst in enumerate(graph[target]) if rst == 1] while stack: lose = stack.pop() for i, rst in enumerate(graph[lose]): # a \u0026gt; b and b \u0026gt; c 면 a \u0026gt; c 임으로 이를 표시함. if not graph[target][i] and rst == 1: graph[target][i], graph[i][target] = 1, -1 stack.append(i) return graph def solution(n,results): answer = 0 #승패를 기록하는 graph 생성 graph = [[0]*(n+1) for _ in range(n+1)] #승패 기록 for win, lose in results: graph[win][lose] = 1 graph[lose][win] = -1 graph = dfs(graph) for i in range(1,n+1): #자기 자신을 제외하고 모든 노드에 승패 표시가 되어있다면 if graph[i][1:].count(0) == 1: answer += 1 return answer ","permalink":"http://slow-wave.github.io/post/problem_solving/bfs_dfs_4/","summary":"[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.\n풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다.","title":"[programmers] DFS/BFS 4- 순위"},{"content":"[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.\n[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.\n[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.\n[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다. *이 과정은 빈 queue가 될 때까지 반복합니다. [2] bfs 함수가 실행된 횟수와 bfs 함수 내부에서 queue에 좌표를 push 할 때마다 count한 횟수를 출력합니다.\nCode (python) from collections import deque def bfs(root): #단지 내의 apt 수 저장하는 변수 cnt = 1 queue = deque([root]) #queue에 원소가 있는 동안 while queue: #x,y pop x,y = queue.popleft() #(x,y)를 기준으로 상,하,좌,우 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] #만약 nx,ny가 범위값 밖에 있다면 continue if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= n or ny \u0026gt;= n: continue #graph(nx,ny)값이 1이고 아직 방문하지 않았다면 if graph[nx][ny]==1 and not visited[nx][ny]: #방문 표시 visited[nx][ny] = True #stack에 표시 queue.append((nx,ny)) #apt 수 증가 cnt += 1 return cnt #입력 n = int(input()) graph,result = [],[] for _ in range(n): line = input() graph.append([int(i) for i in line]) #방문 표시 리스트 생성 visited = [[False]*n for i in range(n)] #상하좌우 이동을 위한 dx,dy 좌표 dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] #graph의 모든 좌표에 대해서 확인 for x in range(n): for y in range(n): #만약 graph(x,y)값이 1이고 아직 방문하지 않았다면 if graph[x][y] == 1 and not visited[x][y]: #방문 표시 visited[x][y] = True #반환되는 단지 내의 apt 수를 저장 apt_n = bfs((x,y)) #result 리스트에 더함 result.append(apt_n) #오름차순으로 정렬 result.sort() #총 apt 단지 수 출력 print(len(result)) #단지 내의 아파트 수 출력 print(*result, sep=\u0026#39;\\n\u0026#39;) ","permalink":"http://slow-wave.github.io/post/problem_solving/bfs_dfs_3/","summary":"[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.\n[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.\n[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.\n[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다.","title":"[백준] DFS/BFS 3- 2667번 단지 번호 붙이기"},{"content":"[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.\nCode (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= N or ny \u0026gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.append([nx,ny]) #좌표를 queue에 push return graph[N-1][M-1] #도착 지점 좌표의 값을 리턴함 graph,root = [],[0,0] N,M = map(int,input().split()) #graph 만들기 for i in range(N): line = input() graph.append([int(i) for i in line]) #좌표 상화좌우 이동을 위한 dx,dy dx = [-1,1,0,0] dy = [0,0,-1,1] print(bfs(root)) ","permalink":"http://slow-wave.github.io/post/problem_solving/bfs_dfs_2/","summary":"[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.\nCode (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= N or ny \u0026gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.","title":"[백준] DFS/BFS 2- 2178번 미로탐색"},{"content":"[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.\n방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!\n풀이 방법 Graph \u0026lt;input\u0026gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.\nDFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.\n인접한 node를 push 할 때 내림차순 정렬해서(3 → 2) 숫자가 작은 node가 먼저 pop 되게 합니다.\nBFS 방식으로 그래프 탐색 queue에서 pop을 하면 처음에 들어온 것이 먼저 나갑니다.\n인접한 node를 push 하기 전에 오름차순 정렬해서(2 → 3) 숫자가 작은 node가 먼저 pop 되게 합니다.\nCode (python) from collections import deque import sys #DFS def DFS(graph, root, visited =[]): stack = [root] #stack을 생성하고 root push while stack: n = stack.pop() if n not in visited: visited.append(n) #visited에 표시 if n in graph: temp = list(set(graph[n]) - set(visited)) temp.sort(reverse = True) #내림차순으로 졍럴 - stack의 Top에 숫자가 작은 것이 위치하게된다. stack += temp #stack에 push return \u0026#34; \u0026#34;.join(str(i) for i in visited) #BFS def BFS(graph, root, visited = []): queue = deque([root]) #queue를 생성하고 root push while queue: n = queue.popleft() if n not in visited: visited.append(n) #visited에 표시 if n in graph: temp = list(set(graph[n]) - set(visited)) temp.sort() #오름차순으로 졍럴 - queue의 Bottom에 숫자가 작은 것이 위치하게된다. queue += temp #queue에 push return \u0026#34; \u0026#34;.join(str(i) for i in visited) input = sys.stdin.readline #N,M,V 입력 받기 N, M, V = map(int,input().split()) #그래프 만들기 - 각 노드마다 연결된 노드를 표시해준다. graph = {} for i in range(M): n1, n2 = map(int,input().split()) graph[n1] = graph.get(n1,[]) + [n2] graph[n2] = graph.get(n2,[]) + [n1] print(DFS(graph, V)) print(BFS(graph, V)) ","permalink":"http://slow-wave.github.io/post/problem_solving/bfs_dfs_1/","summary":"[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.\n방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!\n풀이 방법 Graph \u0026lt;input\u0026gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.\nDFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.","title":"[백준] DFS/BFS 1- 1260번 DFS와 BFS"},{"content":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다. recursion 이용한 순회 방법 (DFS의 경우 재귀 호출을 이용하면 코드가 간결해진다.) 노드에 방문하면 데이터를 출력하고 자식들을 순서대로 재귀호출한다. 자식들이 호출받으면 자기를 출력하고 자식들을 호출 만약 재귀호출을 다녀와서 출력하면 자식들이 먼저 출력하니깐 거꾸로 올라가게됨. 자식이 1개 이상인 경우 stack은 쌓고 나서 호출 → 자식 중에서 나중에 들어간 node가 먼저 출력된다. 재귀 호출은 정방향으로 출력하기 때문에 다르다. 연결 관계를 입력할 때 어떤 노드와의 입력관계를 먼저 입력했느냐로 결정된다. (예시 - L 먼저 입력 됐다고 가정) 활용 모든 노드를 방문 할 때, 완전 탐색을 할 때 사용한다. 시간 복잡도 BFS(Breadth-First-Search) 정의 Root node 혹은 다른 임의의 node에서 시작해서 인접한 node를 먼저 탐색하는 방법이다.\n구현 방법 queue를 이용해서 구현한다.\n처음에는 queue에 node가 없으니깐 시작할 node를 넣는다. queue에서 node를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. 활용 최단 경로를 찾을 때 사용한다. (가중치가 0,1인 경우에만 활용할 수 있다.)\n","permalink":"http://slow-wave.github.io/post/algorithm/bfs_vs_dfs/","summary":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.","title":"[algorithm] DFS vs. BFS"}]