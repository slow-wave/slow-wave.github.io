[{"content":" Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS \u0026lsquo;[boostcourse 웹프로그래밍 풀스택]은\u0026rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.\n깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다. 그래서 원래 강의안의 전체적인 구조를 그대로 가져오되, 개인적으로 깊게 파고 들어본 내용을 더해서 정리하려고 합니다.\n1-1. HTTP 프로토콜의 이해 HTTP (Hypertext Transfer Protocol) 정의 HTTP는 서버와 클라이언트가 인터넷 상에서 데이터를 주고받기 위한 프로토콜입니다. 프로토콜은 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고받기 위해 정의되었습니다. 오늘날에는 거의 모든 파일 형식을 HTTP 형식을 이용해 전송 가능합니다.\nHTTP 특징 HTTP 통신은 connectionless를 기본 동작으로 가집니다. connection을 유지하게되면 지속적으로 resource가 사용되기 때문입니다. 따라서 connection 유지는 최소화되는 것이 좋습니다.\nHTTP 작동 방식 HTTP 프로토콜로 데이터를 주고 받기 위해서는 Request를 보내고 Response를 받아야합니다. Client는 요청을 보내는 쪽을 의미하며 웹 관점에서는 브라우저를 의미합니다. Server는 요청을 받는 쪽을 의미하며 일반적으로 데이터를 보내주는 원격지의 컴퓨터를 의미합니다.\nServer-Client 모델 Server-Client는 1:N 구조로 연결되어 있으며 클라이언트의 요청이 있을 때 서버가 응답하는 단방향 통신입니다. 즉, 한 대의 서버에 다수의 클라이언트가 접속하여 서비스를 이용합니다. 다수의 사용자들이 공동으로 열람·복사·수정·관리하는 데이터를 여러 곳에 분산시키지 않고 단일한 중앙 서버에 저장하여 관리함으로써 데이터의 유일성과 통일성을 보장할 수 있습니다.\nHTTP 프로토콜로 클라이언트가 서버에 요청을 보내고 성공적으로 데이터를 받게되면 동시에 서버와의 연결이 해체되고 보내진 데이터의 결과도 동시에 잃어버리게 됩니다. 이를 Stateless protocol 이라고 부르며 문제를 해결하기 위해 cookie, session, token 기술이 등장했습니다.\nClient란? 네트워크를 이용하여 서버 시스템에 연결된 PC나 스마트폰 등 사용자 측을 의미합니다. Client는 서버에서 받아온 데이터를 단말기 화면에 표시하고 사용자의 요청을 서버에 전달하기 위해 웹브라우저를 사용합니다.\nserver란? 통신망 상에서 다른 컴퓨터에 대해서 회선, 디스크 장치에 대한 접속을 제어하는 소프트웨어 혹은 컴퓨터입니다. web server, WAS, DB server 등이 있습니다.\n참고 자료 [1] 프런트엔드 개발자가 알아야하는 HTTP 프로토콜 Part 1\n[2] 서버-클라이언트\n[3] Http Stateless / cookie / session / token\n[4] Client-Server Model\n[5] HTTP(Hypertext Transfer Protocol)의 특징\n","permalink":"http://slow-wave.github.io/post/fullstack_boostcourse/web_boostcourse_1/","summary":"Web개발의 이해 1-1. HTTP 프로토콜의 이해 1-2. browser의 동작 1-3. 웹서버 1-4. WAS \u0026lsquo;[boostcourse 웹프로그래밍 풀스택]은\u0026rsquo; 네이버 부스트코스의 “웹프로그래밍(풀스택)” 강의를 듣고 공부한 내용을 정리한 시리즈입니다. 일단 저는 Spring 프레임워크를 배워보고 싶어서 이 강의를 수강하게 되었습니다. 전공 공부를 할 때 프로그래밍 언어나 프레임워크 등을 익히는데 가장 효과적이고 재밌었던 방법은 직접 구현 해보는 방법이었습니다. 저는 Node.js 프레임워크와 Java, Javascript 언어를 공부한 경험이 있어서 (기억은 가물가물하지만;) 해당 강의 수강에 도전하게 되었습니다.\n깊게 설명해주시는 것은 아니지만 관련해서 공부하면 좋을 주제들을 많이 던져주는 강의라고 생각합니다.","title":"[boostcourse 웹프로그래밍 풀스택] 1. Web개발의 이해 "},{"content":"[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.\n풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다. 자기 자신을 제외하고 모든 노드에 대해서 승패 여부를 알 수 있을 때만 확실한 순위를 알 수 있습니다.\n만약 5번 노드가 1~4번 노드에 대해서 패배했다면 순위는 5위가 됩니다. 만약 2번 노드가 1,3,4에게 패배하고 5에게 승리했다면 순위는 4위가 됩니다.\n따라서 주어진 정보를 가지고 노드 전체에 대한 승패를 표시하면 답을 구할 수 있습니다.\n자세한 풀이 과정은 다음과 같습니다. 최종 graph의 형태는 다음과 같습니다. 확실한 순위를 알 수 있는 노드는 2,5번으로 총 2개 입니다.\nCode (python) def dfs(graph): #1~N번 노드에 대해서 for target in range(1,n+1): #target 노드가 이긴 노드들을 담음 stack = [i for i, rst in enumerate(graph[target]) if rst == 1] while stack: lose = stack.pop() for i, rst in enumerate(graph[lose]): # a \u0026gt; b and b \u0026gt; c 면 a \u0026gt; c 임으로 이를 표시함. if not graph[target][i] and rst == 1: graph[target][i], graph[i][target] = 1, -1 stack.append(i) return graph def solution(n,results): answer = 0 #승패를 기록하는 graph 생성 graph = [[0]*(n+1) for _ in range(n+1)] #승패 기록 for win, lose in results: graph[win][lose] = 1 graph[lose][win] = -1 graph = dfs(graph) for i in range(1,n+1): #자기 자신을 제외하고 모든 노드에 승패 표시가 되어있다면 if graph[i][1:].count(0) == 1: answer += 1 return answer ","permalink":"http://slow-wave.github.io/post/algo-problem/bfs_dfs_4/","summary":"[programmers] 순위 (문제 링크) 이 문제는 그래프로 분류되어 있습니다. 어떻게 그래프로 접근해야하는지 아이디어가 생각나지 않아서 어려웠던 문제입니다. 구글링을 해봤을 때 플로이드 와샬(Floyd-Warshall) 알고리즘을 이용해서 구현을 하신 답안이 많았지만 DFS로 구현했습니다. 플로이드 와샬의 경우 각 정점에서 다른 모든 정점까지의 최단경로를 구할 수 있는 알고리즘인데 이보다는 DFS가 효율적이라고 생각했습니다. 실제로 플로이드 와샬의 시간 복잡도는 O(n^3)입니다.\n풀이 방법 n = 5 results = [[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]] results의 정보를 가지고 확실한 순위를 알 수 있는 노드의 수를 찾아내는 문제입니다.","title":"[programmers] DFS/BFS 4- 순위"},{"content":"[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.\n[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.\n[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.\n[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다. *이 과정은 빈 queue가 될 때까지 반복합니다. [2] bfs 함수가 실행된 횟수와 bfs 함수 내부에서 queue에 좌표를 push 할 때마다 count한 횟수를 출력합니다.\nCode (python) from collections import deque def bfs(root): #단지 내의 apt 수 저장하는 변수 cnt = 1 queue = deque([root]) #queue에 원소가 있는 동안 while queue: #x,y pop x,y = queue.popleft() #(x,y)를 기준으로 상,하,좌,우 확인 for i in range(4): nx = x + dx[i] ny = y + dy[i] #만약 nx,ny가 범위값 밖에 있다면 continue if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= n or ny \u0026gt;= n: continue #graph(nx,ny)값이 1이고 아직 방문하지 않았다면 if graph[nx][ny]==1 and not visited[nx][ny]: #방문 표시 visited[nx][ny] = True #stack에 표시 queue.append((nx,ny)) #apt 수 증가 cnt += 1 return cnt #입력 n = int(input()) graph,result = [],[] for _ in range(n): line = input() graph.append([int(i) for i in line]) #방문 표시 리스트 생성 visited = [[False]*n for i in range(n)] #상하좌우 이동을 위한 dx,dy 좌표 dx = [1, -1, 0, 0] dy = [0, 0, -1, 1] #graph의 모든 좌표에 대해서 확인 for x in range(n): for y in range(n): #만약 graph(x,y)값이 1이고 아직 방문하지 않았다면 if graph[x][y] == 1 and not visited[x][y]: #방문 표시 visited[x][y] = True #반환되는 단지 내의 apt 수를 저장 apt_n = bfs((x,y)) #result 리스트에 더함 result.append(apt_n) #오름차순으로 정렬 result.sort() #총 apt 단지 수 출력 print(len(result)) #단지 내의 아파트 수 출력 print(*result, sep=\u0026#39;\\n\u0026#39;) ","permalink":"http://slow-wave.github.io/post/algo-problem/bfs_dfs_3/","summary":"[백준] 2667번 단지 번호 붙이기 (문제 링크) 풀이 방법 graph에서 연결 요소(connected component)의 수를 찾고 연결 요소 안의 node 수를 카운트하는 문제입니다. deque로 BFS를 구현해서 해결했습니다.\n[0] graph와 (x,y) 좌표의 방문 여부를 표시하는 visited (list)를 생성합니다.\n[1] graph 전체를 순회하면서 graph(x,y) 값이 1인 경우에 bfs 함수를 실행합니다.\n[1-1] (x,y)를 push한 queue를 생성합니다. [1-2] queue에서 원소를 pop 합니다. [1-3] pop한 원소를 기준값으로 해서 상하좌우를 살핍니다. 만약 값이 1이고 아직 방문하지 않았다면 push 하고, 방문 표시합니다.","title":"[백준] DFS/BFS 3- 2667번 단지 번호 붙이기"},{"content":"[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.\nCode (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= N or ny \u0026gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.append([nx,ny]) #좌표를 queue에 push return graph[N-1][M-1] #도착 지점 좌표의 값을 리턴함 graph,root = [],[0,0] N,M = map(int,input().split()) #graph 만들기 for i in range(N): line = input() graph.append([int(i) for i in line]) #좌표 상화좌우 이동을 위한 dx,dy dx = [-1,1,0,0] dy = [0,0,-1,1] print(bfs(root)) ","permalink":"http://slow-wave.github.io/post/algo-problem/bfs_dfs_2/","summary":"[백준] 2178번 미로탐색 (문제 링크) 풀이 방법 (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다. 이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.\nCode (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= N or ny \u0026gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.","title":"[백준] DFS/BFS 2- 2178번 미로탐색"},{"content":"[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.\n방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!\n풀이 방법 Graph \u0026lt;input\u0026gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.\nDFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.\n인접한 node를 push 할 때 내림차순 정렬해서(3 → 2) 숫자가 작은 node가 먼저 pop 되게 합니다.\nBFS 방식으로 그래프 탐색 queue에서 pop을 하면 처음에 들어온 것이 먼저 나갑니다.\n인접한 node를 push 하기 전에 오름차순 정렬해서(2 → 3) 숫자가 작은 node가 먼저 pop 되게 합니다.\nCode (python) from collections import deque import sys #DFS def DFS(graph, root, visited =[]): stack = [root] #stack을 생성하고 root push while stack: n = stack.pop() if n not in visited: visited.append(n) #visited에 표시 if n in graph: temp = list(set(graph[n]) - set(visited)) temp.sort(reverse = True) #내림차순으로 졍럴 - stack의 Top에 숫자가 작은 것이 위치하게된다. stack += temp #stack에 push return \u0026#34; \u0026#34;.join(str(i) for i in visited) #BFS def BFS(graph, root, visited = []): queue = deque([root]) #queue를 생성하고 root push while queue: n = queue.popleft() if n not in visited: visited.append(n) #visited에 표시 if n in graph: temp = list(set(graph[n]) - set(visited)) temp.sort() #오름차순으로 졍럴 - queue의 Bottom에 숫자가 작은 것이 위치하게된다. queue += temp #queue에 push return \u0026#34; \u0026#34;.join(str(i) for i in visited) input = sys.stdin.readline #N,M,V 입력 받기 N, M, V = map(int,input().split()) #그래프 만들기 - 각 노드마다 연결된 노드를 표시해준다. graph = {} for i in range(M): n1, n2 = map(int,input().split()) graph[n1] = graph.get(n1,[]) + [n2] graph[n2] = graph.get(n2,[]) + [n1] print(DFS(graph, V)) print(BFS(graph, V)) ","permalink":"http://slow-wave.github.io/post/algo-problem/bfs_dfs_1/","summary":"[백준] 1260번 DFS와 BFS (문제 링크) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.\n방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!\n풀이 방법 Graph \u0026lt;input\u0026gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.\nDFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.","title":"[백준] DFS/BFS 1- 1260번 DFS와 BFS"},{"content":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다. recursion 이용한 순회 방법 (DFS의 경우 재귀 호출을 이용하면 코드가 간결해진다.) 노드에 방문하면 데이터를 출력하고 자식들을 순서대로 재귀호출한다. 자식들이 호출받으면 자기를 출력하고 자식들을 호출 만약 재귀호출을 다녀와서 출력하면 자식들이 먼저 출력하니깐 거꾸로 올라가게됨. 자식이 1개 이상인 경우 stack은 쌓고 나서 호출 → 자식 중에서 나중에 들어간 node가 먼저 출력된다. 재귀 호출은 정방향으로 출력하기 때문에 다르다. 연결 관계를 입력할 때 어떤 노드와의 입력관계를 먼저 입력했느냐로 결정된다. (예시 - L 먼저 입력 됐다고 가정) 활용 모든 노드를 방문 할 때, 완전 탐색을 할 때 사용한다. 시간 복잡도 BFS(Breadth-First-Search) 정의 Root node 혹은 다른 임의의 node에서 시작해서 인접한 node를 먼저 탐색하는 방법이다.\n구현 방법 queue를 이용해서 구현한다.\n처음에는 queue에 node가 없으니깐 시작할 node를 넣는다. queue에서 node를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. 활용 최단 경로를 찾을 때 사용한다. (가중치가 0,1인 경우에만 활용할 수 있다.)\n","permalink":"http://slow-wave.github.io/post/algorithm/bfs_vs_dfs/","summary":"Graph Search graph search 방법에는 DFS, BFS 2가지 종류가 있다.\nDFS(Depth-First-Search) 정의 root node 혹은 다른 임의의 node에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식이다.\nbinary tree를 순회할 때 사용했던 다음의 순회 방법이 DFS에 속한다.\ninorder preorder postorder 구현 방법 stack을 이용해서 구현 처음에는 스택에 노드가 없으니깐 시작할 노드를 넣는다. stack에서 노드를 하나 꺼내서 해당 node의 child node를 전부 스택에 넣고 꺼낸 노드는 출력한다. child node를 stack에 넣을 때 한번 stack에 넣었던 node는 다시 넣지 않는다.","title":"[알고리즘] DFS vs. BFS"}]