<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>백준 on My New Hugo Site</title>
    <link>http://slow-wave.github.io/tags/%EB%B0%B1%EC%A4%80/</link>
    <description>Recent content in 백준 on My New Hugo Site</description>
    <image>
      <url>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://slow-wave.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 19 Aug 2022 17:11:21 +0900</lastBuildDate><atom:link href="http://slow-wave.github.io/tags/%EB%B0%B1%EC%A4%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[백준] DFS/BFS 구현 문제 2- 2178번 미로탐색</title>
      <link>http://slow-wave.github.io/post/algorithm/bfs_dfs_2/</link>
      <pubDate>Fri, 19 Aug 2022 17:11:21 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/bfs_dfs_2/</guid>
      <description>문제 (link) (1,1) ~ (N,M) 까지의 최단 경로를 구하는 문제이므로 BFS를 활용해서 구현합니다.
이 문제에서 BFS를 활용하여 구현하는 이유는 다음과 같습니다.
Code (python) from collections import deque def bfs(root): queue = deque([root]) #큐를 생성해서 root push while queue: x,y = queue.popleft() #pop - 기본 좌표가 나옴 #상하좌우 이동 for i in range(4): nx = x + dx[i] ny = y + dy[i] #좌표 밖을 벗어나면 넘어감 if nx &amp;lt; 0 or ny &amp;lt; 0 or nx &amp;gt;= N or ny &amp;gt;= M: continue if graph[nx][ny] == 1: #만약 이동한 좌표의 값이 1이라면 graph[nx][ny] = graph[x][y] + 1 #이동한 좌표의 값에 기본 좌표 값에 1을 더함 queue.</description>
    </item>
    
    <item>
      <title>[백준] DFS/BFS 구현 문제 1- 1260번 DFS와 BFS</title>
      <link>http://slow-wave.github.io/post/algorithm/bfs_dfs_1/</link>
      <pubDate>Fri, 12 Aug 2022 22:29:58 +0900</pubDate>
      
      <guid>http://slow-wave.github.io/post/algorithm/bfs_dfs_1/</guid>
      <description>문제 (link) 기본적인 그래프 탐색 문제 입니다. DFS는 stack을 활용해서 구현하고, BFS는 queue를 활용해 구현합니다.
방문할 수 있는 정점이 여러 개인 경우 숫자가 적은 것을 먼저 방문하라는 조건을 고려해야 합니다!
풀이 방법 Graph &amp;lt;input&amp;gt; 4 5 1 1 2 1 3 1 4 2 4 3 4 위의 testcase로 만들어진 그래프의 모양은 다음과 같습니다.
DFS 방식으로 그래프 탐색 stack 자료구조에서 pop을 하면 나중에 들어온 것이 먼저 나옵니다.
인접한 node를 push 할 때 내림차순 정렬해서(3 → 2) 숫자가 작은 node가 먼저 pop 되게 합니다.</description>
    </item>
    
  </channel>
</rss>
